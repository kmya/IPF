---
title: "特发性肺纤维化关键基因寻找和免疫浸润细胞分析"
date: "`r Sys.Date()`"
output:
  html_document:
    highlight: tango
    toc: yes
    toc_depth: 3
    toc_float: yes
  word_document:
    toc: yes
    toc_depth: '4'
editor_options: 
  chunk_output_type: inline
---


<style type="text/css">
h1 { /* Header 1 */
  font-size: 26px;
  font-weight:bold;
  font-family:微软雅黑;
}
h2 { /* Header 2 */
    font-size: 24px;
    font-weight:bold;
    font-family:微软雅黑;
}
h3 { /* Header 3 */
    font-size: 22px;
    font-weight:bold;
    font-family:微软雅黑;
}
<!-- p {/* 正文 */ -->
<!--     font-size: 20px; -->
<!--     font-family:微软雅黑; -->
<!--     text-align:left; -->
<!--     padding-left:1em; -->
<!--     padding-right:1em; -->
<!--     text-indent:2em; -->
<!--     line-height: 1.5em -->
<!--     } -->
<!-- </style> -->


<style>
.legend{
  font-size: 15px;
  font-family:微软雅黑,"Times New Roman";
  clear:both;width:600px;border:1px solid white;text-align:center;margin:auto;
  line-height: 1.2em
}
</style>



```{r setup, include=T,warning=FALSE,echo = F}
knitr::opts_chunk$set(eval=TRUE, #在块中运行代码(default = TRUE)
                      highlight = T, #高亮显示
                      echo = F, #是否在输出中包含源代码
                      tidy=TRUE,#是否整理代码
                      error = F, #是否在输出中包含错误信息
                      warning = F, #是否在输出中包含警告(default = TRUE)
                      message  = F, #是否在输出中包含参考的信息
                      cache=T
                      )

```

 
```{r packages_library}
rm(list = ls())
save.fig = F
source('scripts/GEOdownloaddata.r')
source('scripts/DEG分析可视化.R')
suppressMessages(library(rvcheck)
suppressMessages(library(dplyr))
suppressMessages(library(tableone))
suppressMessages(library(stringr))
suppressMessages(library(progress))
suppressMessages(library(kableExtra))
suppressMessages(library(formattable))
suppressMessages(library(ggplot2))
suppressMessages(library(lncRNAtools)
suppressMessages(library(data.table))
suppressMessages(library(GDCRNATools))
suppressMessages(library(edgeR))
suppressMessages(library(DESeq2))
suppressMessages(library(pheatmap))
suppressMessages(library(rjson))
suppressMessages(library(survival))
suppressMessages(library(Biobase))
suppressMessages(library(GEOquery))
suppressMessages(library(pheatmap))
suppressMessages(library(limma))
suppressMessages(library(clusterProfiler))
suppressMessages(library(org.Hs.eg.db))
suppressMessages(library(gplots))
suppressMessages(library(GEOmirror))
suppressMessages(library("FactoMineR"))
suppressMessages(library("factoextra"))
suppressMessages(library(idmap2))
suppressMessages(library(enrichplot))
suppressMessages(library(ReactomePA))
suppressMessages(library(survminer))
suppressMessages(library(survival))
suppressMessages(library(rms))
suppressMessages(library("pROC"))
suppressMessages(library(survivalROC))
suppressMessages(library(GOplot))
suppressMessages(library(nnet))
suppressMessages(library(RColorBrewer))
suppressMessages(library(RCurl))
suppressMessages(library("glmnet"))
suppressMessages(library(DOSE))
suppressMessages(library(threejs))
suppressMessages(library(htmlwidgets))
suppressMessages(library(corrplot))
suppressMessages(library(GSVA))
suppressMessages(library(estimate))
suppressMessages(library(table1))
suppressMessages(library(openxlsx))
suppressMessages(library(DOSE))
suppressMessages(library(threejs))
suppressMessages(library(htmlwidgets))
suppressMessages(library(corrplot))
suppressMessages(library(WGCNA))
suppressMessages(library(RColorBrewer))
suppressMessages(library(ggplot2))
suppressMessages(library(e1071))
```

# 一、数据获取及分析流程

## 1.数据获取

包含正常和IFP的数据集：

- GSE110147：从接受肺移植的22名IPF患者、10名NSIP患者和5名IPF-NSIP混合患者的受者器官获取新鲜冷冻肺样本。特发性肺纤维化(IPF)和非特异性间质性肺炎(NSIP) ；
- GSE53845：从40名IPF患者或8名健康对照的肺组织样本中提取的；
- GSE35145：4个IPF肺组织和4个正常肺组织样本；
- GSE24206：来自11名IPF患者的17个样本（6名患者提供了一对上下叶的样本；5名患者提供了单例样本）；6个对照标本是在肺移植时从健康供体肺的常规肺减容中获得的；

包含IFP进展的的数据集：

- GSE124685：重度IPF肺移植后收集的人肺中的多个区域进行采样，并使用microCT定量成像和组织组织学确定纤维化的程度，将它们分类为早期、进行性或末期纤维化（优先选择）。该数据集包含84例样本，其中正常35例，定义为IFP1（早期）的有19例，定义为IFP2（进行性）的有16例，定义为IFP3（末期纤维化）的有14例。
- GSE33566：按DLCO或FVC的严重程度将IPF疾病样本分类为轻微类型和严重类型（优先选择）。该数据集包含有123例外周血样本，其中包含有30例正常样本，另外93例为IFP样本，按照作者的的区分方法，dlco大于等于65或fvp大于等于75为轻微，dlco小于等于35或fvp小于等于50为严重，最终筛选得到35例轻微类型的样本和26例验证类型的样本。

舍弃的数据集：

- GSE31934：芯片平台只检测了1259个基因的表达（舍弃）；
- GSE73854：支气管肺泡灌洗液衍生的间充质基质细胞比较稳定和渐进性IPF的整体mRNA表达（舍弃）；
- GSE15197：继发于特发性肺纤维化(IPF)的PAH(n=18)、PH(n=8)和正常对照(n=13)新鲜冷冻肺组织标本（舍弃）；
- GSE73845：原代胶质瘤细胞系中RNA结合蛋白IMP2的功能表征（应该是编号错了、舍弃）；

最终选择GSE124685作为主要的数据集，进行wgcna分析、免疫浸润分析和富集分析，另外选择GSE33566作为验证集。

## 2.分析流程

- 使用GSE124685进行wgcna分析筛选和IFP进展相关的模块；
- 模块基因和差异基因取交集获取关键基因；
- 免疫浸润分析；
- 筛选与成纤维细胞及肌成纤维细胞相关的关键基因；
- 验证集中验证建议的表达；
- 候选基因建模查看基因对IFP早期的识别能力；
- 候选基因的单基因GSEA富集分析。

```{r eval=F}
dir.create('Result/')
dir.create('Result/1.rawdata')
GEOnumber="GSE124685"
gplnumber='GPL17303'
GSE124685 <- read.table('data/GSE124685_FPKM_Matrix_84_samples.txt',header = T,stringsAsFactors = F)

data <- data.frame(genename=GSE124685[,1],GSE124685[,-(1:8)])
data$median <- apply(data[,-1],1,median)#计算每行的中位数，添加到 data数据中
data=data[order(data$genename,data$median,decreasing = T),]#排序
data=data[!duplicated(data$genename),]#去除重复的基因名
if(length(which(data$genename=='---'| is.na(data$genename)))>0){
  data <- data[-which(data$genename=='---'| is.na(data$genename)),]
}
rownames(data)=data$genename#把基因名变成行名
GSE124685rnaCounts <- data[,-c(1,ncol(data))]
GSE124685rnaCounts <- round(log2(GSE124685rnaCounts+1),2)

GSE124685pdata <- read.csv('Clinical data for JCI insight paper.csv',stringsAsFactors = F)
GSE124685sample <- read.table('GSE53845sample.txt',header = F,stringsAsFactors = F)
# GSE124685sample$V3 <- paste0('x',GSE124685sample$V2)

GSE124685pdata$sample <- GSE124685sample$V1[match(GSE124685pdata$SAMPLE,GSE124685sample$V2)]
GSE124685pdata <- GSE124685pdata[-which(is.na(GSE124685pdata$sample)),]
rownames(GSE124685pdata) <- GSE124685pdata$sample

write.csv(GSE124685pdata,file = 'Result/1.rawdata/GSE124685clidata.csv',quote = F)
write.table(GSE124685rnaCounts,file = 'Result/1.rawdata/GSE124685rawdata.txt',quote = F,sep = '\t')
#save(GSE124685pdata,GSE124685rnaCounts,file = 'GSE124685.rda')
```


```{r eval=F}
dir.create('Result/')
dir.create('Result/1.rawdata')
GEOnumber="GSE53845"
gplnumber='GPL6480'
data <- GEOdownloaddata(GEOnumber,gplnumber)
GSE53845rnaCounts <- data[[1]]
GSE53845pdata <- data[[2]]
write.csv(GSE53845pdata,file = 'Result/1.rawdata/GSE53845clidata.csv',quote = F)
write.table(GSE53845rnaCounts,file = 'Result/1.rawdata/GSE53845rawdata.txt',quote = F,sep = '\t')
#save(GSE53845pdata,GSE53845rnaCounts,file = 'GSE53845.rda')
```

```{r eval=F}
dir.create('Result/')
dir.create('Result/1.rawdata')
GEOnumber="GSE33566"
gplnumber='GPL6480'
data <- GEOdownloaddata(GEOnumber,gplnumber)
GSE33566rnaCounts <- data[[1]]
GSE33566pdata <- data[[2]]
write.csv(GSE33566pdata,file = 'Result/1.rawdata/GSE33566clidata.csv',quote = F)
write.table(GSE33566rnaCounts,file = 'Result/1.rawdata/GSE33566rawdata.txt',quote = F,sep = '\t')
#save(GSE33566pdata,GSE33566rnaCounts,file = 'GSE33566.rda')
```

```{r eval=F}
GSE33566pdata$`fvp:ch1` <- as.numeric(GSE33566pdata$`fvp:ch1`)
GSE33566pdata$`dlco:ch1` <- as.numeric(GSE33566pdata$`dlco:ch1`)

table(as.numeric(GSE33566pdata$`dlco:ch1`)>=65)
# table(GSE33566pdata$source_name_ch1[which(as.numeric(GSE33566pdata$`dlco:ch1`)>=65)])
table(as.numeric(GSE33566pdata$`dlco:ch1`)<=35)
# table(GSE33566pdata$source_name_ch1[which(as.numeric(GSE33566pdata$`dlco:ch1`)<=35)])

table(as.numeric(GSE33566pdata$`fvp:ch1`)>=75)
table(as.numeric(GSE33566pdata$`fvp:ch1`)<=50)

# table(GSE33566pdata$source_name_ch1)
```

# 二、结果

## 2.1 wgcna分析

```{r}
load('GSE124685.rda')

```

WGCNA（weighted gene co-expression network analysis，加权基因共表达网络分析）是一种分析多个样本基因表达模式的分析方法，可将表达模式相似的基因进行聚类，分析模块与特定性状或表型之间的关联关系，因此在疾病以及其他性状与基因关联分析等方面的研究中被广泛应用，不少文章运用该方法来寻找潜在生物标志物以及药物靶点。然后通过基因表达相似性对模块进行区分，接着计算模块与模块之间的相关性以及模块与样本性状之间的相关性，从而筛选性状高度相关的模型，并对模块中的基因进行分析，从而找到与研究相关的目标基因。

本次研究使用R包“WGCNA”去除掉所有GSE124685数据集中缺失值过多的基因，剩余的基因用于构建共表达网络，利用是否患有IFP及IFP的进展情况作为WGCNA的性状数据。首先，对样本进行聚类，如图1所示。通过样本的聚类情况，查看是否需要删除离群样本，以保证后面分析部分的准确性。图5中性状聚类属正常情况故不对样本进行剔除处理。


```{r}
# filterloc <- which(!(is.na(GSE33566pdata$`fvp:ch1`) & is.na(GSE33566pdata$`dlco:ch1`)))
# filterloc <- c(filterloc,which(GSE33566pdata$source_name_ch1=='healthy control (N)_PBB'))
dir.create('Result/2.WGCNA')
dataExpr <-data.frame(t(GSE124685rnaCounts),check.names = F)
# dim(dataExpr)
dataTraits <- as.data.frame(GSE124685pdata[,c(2:3,6:9)])
dataTraits$DISEASE <- ifelse(dataTraits$DISEASE == 'CONTROL',0,1)
dataTraits$grp_PCA.EM <- ifelse(dataTraits$grp_PCA.EM == 'CONTROL',NA,
                                ifelse(dataTraits$grp_PCA.EM == 'IPF1',1,
                                       ifelse(dataTraits$grp_PCA.EM == 'IPF2',2,3)))
IFP <- class.ind(dataTraits$grp_PCA.EM)
colnames(IFP) <- c('IFP1','IFP2','IFP3')
# IFP[which(dataTraits$DISEASE == 0),1:3] <- NA
dataTraits <- cbind(dataTraits,IFP)
dataTraits <- dataTraits[rownames(dataExpr),]
save(dataExpr,dataTraits,file = 'dataExpr4class.Rdata')
```




```{r results=F,eval=F}
# 检查所有基因和样本的缺失值是否足够低。
gsg = goodSamplesGenes(dataExpr, verbose = 3);
if (!gsg$allOK){
  # Optionally, print the gene and sample names that were removed:
  if (sum(!gsg$goodGenes)>0) 
    printFlush(paste("Removing genes:", 
                     paste(names(dataExpr)[!gsg$goodGenes], collapse = ",")));
  if (sum(!gsg$goodSamples)>0) 
    printFlush(paste("Removing samples:", 
                     paste(rownames(dataExpr)[!gsg$goodSamples], collapse = ",")));
  # Remove the offending genes and samples from the data:
  dataExpr = dataExpr[gsg$goodSamples, gsg$goodGenes]
}
nGenes = ncol(dataExpr)
nSamples = nrow(dataExpr)
# dim(dataExpr)
write.csv(dataExpr,file = 'Result/2.WGCNA/WGCNA data.csv')
# save(dataExpr,file = 'dataExpr2.Rdata')
```

```{r eval=F}
sampleTree = hclust(dist(dataExpr), method = "complete")
# pdf(file = "Fig1.Sample_cluster.pdf", width = 7, height = 5)
# par(mar = c(0,10,2,0),xpd=F)
# plot(sampleTree, main = "Sample clustering to detect outliers", cex.main=1,sub="", xlab="")
#abline(h = 91, col = "red")
# dev.off()
```

```{r,fig.cap = '<div class="legend">**图1. 样本聚类图**<br> 图中的上半部分是聚类情况，分支代表样本，纵坐标代表层次聚类的高度，下半部分是表型。</div>' ,fig.width=12,fig.height=8,fig.align='center'}
# GSE124685pdata$source_name_ch1 <- ifelse(GSE124685pdata$source_name_ch1 == 'healthy control (N)_PBB',0,1)
# head(dataTraits)
load('dataExpr2.Rdata')
colnames(dataTraits) <- c("DISEASE","IFPType","PKYR","FEV1pp","FVCpp","DLCOpp","IFP1","IFP2","IFP3")
sampleTree2 = hclust(dist(dataExpr), method = "complete")
traitColors = numbers2colors(dataTraits, signed = FALSE)
if(save.fig == T){
  pdf("Result/2.WGCNA/图1. 样本聚类图.pdf",width=10,height=10)
  plotDendroAndColors(sampleTree2, traitColors,
                    groupLabels = colnames(dataTraits),cex.dendroLabels=0.7,marAll = c(1, 9, 3, 1),
                    main = "Sample dendrogram and trait heatmap")
  dev.off()
}else{
  plotDendroAndColors(sampleTree2, traitColors,
                    groupLabels = colnames(dataTraits),cex.dendroLabels=0.7,marAll = c(1, 9, 3, 1),
                    main = "Sample dendrogram and trait heatmap")
}
#save(dataExpr,file='dataExpr.Rdata')
```
```{r}
clusters <- cutree(sampleTree2, k = 2)
clustering <- data.frame(clusters)
clustering[, 1] <- as.character(clustering[, 1])
# table(clustering)
sampledel <- rownames(clustering)[which(clustering$clusters == 2)]
```


```{r eval=F}
###power值散点图
enableWGCNAThreads()   #多线程工作
powers =seq(from = 1, to=20, by=1)  #幂指数范围1:20
sft = pickSoftThreshold(dataExpr, powerVector = powers, verbose = 5)
# save(sft,file='sft2.Rdata')
```

接着我们开始筛选软阈值，如图2所示。横轴代表权重参数，左图纵轴 scale-free fit index，即 signed R2，是对应的网络中 log(k)与 log(p(k))相关系数的平方R2。相关系数的平方越高，说明该网络越逼近无网路尺度的分布。右图的纵轴代表对应的基因模块中所有基因邻接函数的均值。WGCNA 包中的推荐的最佳power 值为8，根据图中的红线位置，确定power阈值选为8，即此时的图2（左） 的纵坐标R2在0.85左右，说明该网络越逼近无尺度分布，且图 2（右）中邻接函数的均值也逐渐接近于 0，呈现出平缓的趋势。

```{r,fig.cap = '<div class="legend">**图2. 软阈值筛选**<br> </div>' ,fig.width=12,fig.height=8,fig.align='center'}
load('sft2.Rdata')
powers =seq(from = 1, to=20, by=1)  #幂指数范围1:20
if(save.fig == T){
pdf('Result/2.WGCNA/图2. 软阈值筛选.pdf',width = 10,height = 6)
par(mfrow = c(1,2))
cex1 = 0.9
###拟合指数与power值散点图
plot(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
     xlab="Soft Threshold (power)",ylab="Scale Free Topology Model Fit,signed R^2",type="n",
     main = paste("Scale independence"));
text(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
     labels=powers,cex=cex1,col="red")
abline(h=0.85,col="red") #可以修改
###平均连通性与power值散点图
plot(sft$fitIndices[,1], sft$fitIndices[,5],
     xlab="Soft Threshold (power)",ylab="Mean Connectivity", type="n",
     main = paste("Mean connectivity"))
text(sft$fitIndices[,1], sft$fitIndices[,5], labels=powers, cex=cex1,col="red")
dev.off()
}else{
  # pdf('Fig2.Soft.Threshold.pdf',width = 10,height = 6)
par(mfrow = c(1,2))
cex1 = 0.9
###拟合指数与power值散点图
plot(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
     xlab="Soft Threshold (power)",ylab="Scale Free Topology Model Fit,signed R^2",type="n",
     main = paste("Scale independence"));
text(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
     labels=powers,cex=cex1,col="red")
abline(h=0.85,col="red") #可以修改
###平均连通性与power值散点图
plot(sft$fitIndices[,1], sft$fitIndices[,5],
     xlab="Soft Threshold (power)",ylab="Mean Connectivity", type="n",
     main = paste("Mean connectivity"))
text(sft$fitIndices[,1], sft$fitIndices[,5], labels=powers, cex=cex1,col="red")
# dev.off()
}
```

```{r eval=F}
###邻接矩阵转换
softPower =sft$powerEstimate #最佳power值
#服务器跑
adjacency = adjacency(dataExpr, power = softPower)
softPower
###TOM矩阵,服务器跑
TOM = TOMsimilarity(adjacency)
dissTOM = 1-TOM
# save(dissTOM,file='dissTOM2.Rdata')
# load('dissTOM2.Rdata')
###基因聚类，服务器跑
geneTree = hclust(as.dist(dissTOM), method = "average")
# save(geneTree,file='geneTree2.Rdata')
```

```{r eval=F}
load('geneTree2.Rdata')
# pdf(file="Gene.cluster.pdf",width=6,height=5)
# png(file="Gene.cluster.png",width=600,height=500)
plot(geneTree, xlab="", sub="", main = "Gene clustering on TOM-based dissimilarity",
     labels = FALSE, hang = 0.04)
# dev.off()
```

```{r eval=F}
load('geneTree2.Rdata')
###动态剪切模块识识别
#服务器跑
minModuleSize =  100  #模块基因数目
dynamicMods = cutreeDynamic(dendro = geneTree, distM = dissTOM,
                            deepSplit = 2, pamRespectsDendro = FALSE,
                            minClusterSize = minModuleSize);
#save(dynamicMods,file='dynamicMods2.Rdata')
```

构建共表达矩阵的核心是把输入的表达矩阵的几万个基因归类成了几十个模块。大体思路：计算基因间的邻接性，根据邻接性计算基因间的相似性，然后推出基因间的相异性系数，并据此得到基因间的系统聚类树。然后按照混合动态剪切树算法（dynamic tree cutting）的标准，构建网络图，如图3所示。

```{r,fig.cap = '<div class="legend">**图3. 模块划分**<br> 基因通过层次聚类被分为各种模块，不同的颜色代表不同的模块，其中灰色默认是无法归类于任何模块的基因。</div>' ,fig.width=12,fig.height=8,fig.align='center'}
load('geneTree2.Rdata')
load('dynamicMods2.Rdata')
# table(dynamicMods)
dynamicColors = labels2colors(dynamicMods)
# table(dynamicColors)
if(save.fig == T){
  pdf(file="Result/2.WGCNA/图3. 模块划分.pdf",width=6,height=5)
  plotDendroAndColors(geneTree, dynamicColors, "Dynamic Tree Cut",
                      dendroLabels = FALSE, hang = 0.03,
                      addGuide = TRUE, guideHang = 0.05,
                      main = "Gene dendrogram and module colors")
  dev.off()
}else{
  plotDendroAndColors(geneTree, dynamicColors, "Dynamic Tree Cut",
                    dendroLabels = FALSE, hang = 0.03,
                    addGuide = TRUE, guideHang = 0.05,
                    main = "Gene dendrogram and module colors")
}
```

将 MEDissThres设置为0.2以合并动态剪切树算法分析出的类似模块，如图4所示，合并后生成如图5所示的模块图（在此过程中实际并未产生合并，所以这里在使用的使用可以直接用一开始的模块，不再强调该合并模块的步骤）。

```{r ,fig.cap = '<div class="legend">**图4. 相似模块**<br> </div>' ,fig.width=12,fig.height=8,fig.align='center'}
###相似模块聚类
MEList = moduleEigengenes(dataExpr, colors = dynamicColors)
MEs = MEList$eigengenes
#如果不合并，运行下两行
# moduleColors = MEList$validColors
# table(moduleColors)
MEDiss = 1-cor(MEs);
METree = hclust(as.dist(MEDiss), method = "average")
if(save.fig == T){
pdf('Result/2.WGCNA/图4. 相似模块.pdf',width = 9,height = 5)
#png('Fig4.merge.cluster.png',width = 600,height = 400)
plot(METree, main = "Clustering of module eigengenes",
     xlab = "", sub = "")
MEDissThres = 0.2  #剪切高度可修改
abline(h=MEDissThres, col = "red")
dev.off()
}else{
  # pdf('Fig5.merge.cluster.pdf',width = 9,height = 5)
#png('Fig4.merge.cluster.png',width = 600,height = 400)
plot(METree, main = "Clustering of module eigengenes",
     xlab = "", sub = "")
MEDissThres = 0.2  #剪切高度可修改
abline(h=MEDissThres, col = "red")
# dev.off()
}
```

```{r,fig.cap = '<div class="legend">**图5. 模块合并**<br> </div>' ,fig.width=12,fig.height=8,fig.align='center',results=F}
###相似模块合并
merge = mergeCloseModules(dataExpr, dynamicColors, cutHeight = MEDissThres, verbose = 3)
mergedColors = merge$colors
mergedMEs = merge$newMEs
if(save.fig == T){
pdf(file="Result/2.WGCNA/图5. 模块合并.pdf",width=6,height=5)
plotDendroAndColors(geneTree, cbind(dynamicColors,mergedColors),c("Dynamic Tree Cut","Merged dynamic"),
                    dendroLabels = FALSE, hang = 0.03,
                    addGuide = TRUE, guideHang = 0.05,
                    main = "Gene dendrogram and module colors")
dev.off()
}else{
  plotDendroAndColors(geneTree, cbind(dynamicColors,mergedColors),c("Dynamic Tree Cut","Merged dynamic"),
                    dendroLabels = FALSE, hang = 0.03,
                    addGuide = TRUE, guideHang = 0.05,
                    main = "Gene dendrogram and module colors")
}
```
我们计算了模块与性状的相关性，如图6所示。在这11个模块中，MEturquoise模块与疾病状态和疾病进展情况均有较强的相关性（相关性均大于0.4且p值小于0.05）。因此MEturquoise模块识别为关键模块，MEturquoise模块有4603个基因。最后我们绘制了散点图以展示模块基因与模块的相关性以及模块基因与疾病性状的相关性，如图7所示。

```{r ,fig.cap = '<div class="legend">**图6. 模块与性状的相关性**<br> 纵坐标为不同模块，横坐标为不同性状，每一个方块表示某模块和某性状的相关性系数和显著性P值。</div>' ,fig.width=8,fig.height=8,fig.align='center'}
moduleColors = mergedColors
save(moduleColors,file = 'moduleColors.Rdata')
# table(moduleColors)
colorOrder = c("grey", standardColors(30))
moduleLabels = match(moduleColors, colorOrder)-1
MEs = mergedMEs

###模块与性状数据热图
nGenes = ncol(dataExpr)
nSamples = nrow(dataExpr)
moduleTraitCor = cor(MEs, dataTraits, use = "p")
moduleTraitPvalue = corPvalueStudent(moduleTraitCor, nSamples)
textMatrix = paste(signif(moduleTraitCor, 2), "\n(",
                   signif(moduleTraitPvalue, 1), ")", sep = "")
dim(textMatrix) = dim(moduleTraitCor)
write.table(moduleTraitPvalue,'moduleTraitPvalue.txt',sep = '\t',quote = F,row.names = T)
write.table(moduleTraitCor,'moduleTraitCor.txt',sep = '\t',quote = F,row.names = T)
if(save.fig == T){
pdf(file="Result/2.WGCNA/图6. 模块与性状的相关性.pdf",width=10,height=10)
par(mar = c(10, 8, 4, 6))
labeledHeatmap(Matrix = moduleTraitCor,
               xLabels = colnames(dataTraits),
               yLabels = names(MEs),
               ySymbols = names(MEs),
               colorLabels = FALSE,
               colors = blueWhiteRed(500),
               textMatrix = textMatrix,
               setStdMargins = FALSE,
               cex.text =0.5,
               main = paste("Module-trait relationships"))
dev.off()
}else{
  par(mar = c(10, 8, 4, 6))
labeledHeatmap(Matrix = moduleTraitCor,
               xLabels = colnames(dataTraits),
               yLabels = names(MEs),
               ySymbols = names(MEs),
               colorLabels = FALSE,
               colors = blueWhiteRed(500),
               textMatrix = textMatrix,
               setStdMargins = FALSE,
               cex.text =0.5,
               main = paste("Module-trait relationships"))
}
```

```{r,fig.height=8,eval=F}
#大于两列：
par(mar = c(10, 8, 4, 6))
labeledHeatmap(Matrix = moduleTraitCor,
               xLabels = colnames(dataTraits),
               yLabels = names(MEs),
               ySymbols = names(MEs),
               colorLabels = FALSE,
               colors = blueWhiteRed(500),
               textMatrix = textMatrix,
               setStdMargins = FALSE,
               cex.text =0.5,
               main = paste("Module-trait relationships"))
# dev.off()
```

```{r,fig.cap = '<div class="legend">**图7. turquoise模块内基因与模块及性状的相关性**<br> </div>' ,fig.width=12,fig.height=12,fig.align='center'}
###计算MM和GS值
#modNames = substring(names(MEs), 3)
#modNames <- c('turquoise','turquoiseyellow','yellow','cyan','grey60','red')
modNames <- unique(moduleColors)
geneModuleMembership = as.data.frame(cor(dataExpr, MEs, use = "p"))
MMPvalue = as.data.frame(corPvalueStudent(as.matrix(geneModuleMembership), nSamples))
#names(geneModuleMembership) = paste("MM", modNames, sep="")
#names(MMPvalue) = paste("p.MM", modNames, sep="")
traitNames=colnames(dataTraits)
geneTraitSignificance = as.data.frame(cor(dataExpr, dataTraits, use = "p"))
GSPvalue = as.data.frame(corPvalueStudent(as.matrix(geneTraitSignificance), nSamples))
names(geneTraitSignificance) = paste("GS.", traitNames, sep="")
names(GSPvalue) = paste("p.GS.", traitNames, sep="")
cols <- brewer.pal(9,'Set1')
#基因与性状的相关性
coli=0

if(save.fig == T){
  # par(mfrow=c(4,2))
  # par(mfrow=c(3,3))
  for (i in colnames(geneTraitSignificance)){
    pdf(paste0('Result/2.WGCNA/图7. ','模块内基因与模块及性状',substr(i,4,nchar(i)),'的相关性.pdf'),width = 8,height = 8)
    coli <- coli+1
    moduleGenes = moduleColors=='turquoise'
    verboseScatterplot(abs(geneModuleMembership[moduleGenes, 'MEturquoise']),
                       abs(geneTraitSignificance[moduleGenes,i]),
                       xlab = ("Module Membership in turquoise module"),
                       ylab = paste("Gene significance"),
                       main = paste0('Trait ',substr(i,4,nchar(i)),""),
                       cex.main = 1.5, cex.lab = 1.5, cex.axis = 1.5, col = cols[coli])
    abline(h=0.2,v=0.8,col="black")
    dev.off()
  }
}else{
  par(mfrow=c(3,3))
  for (i in colnames(geneTraitSignificance)){
    # pdf(paste0('Result/2.WGCNA/图11. ',substr(i,4,nchar(i)),'模块内基因与模块及疾病性状的相关性.pdf'),width = 8,height = 8)
    coli <- coli+1
    moduleGenes = moduleColors=='turquoise'
    verboseScatterplot(abs(geneModuleMembership[moduleGenes, 'MEturquoise']),
                       abs(geneTraitSignificance[moduleGenes,i]),
                       xlab = ("Module Membership in turquoise module"),
                       ylab = paste("Gene significance"),
                       main = paste0('Trait ',substr(i,4,nchar(i)),""),
                       cex.main = 1.5, cex.lab = 1.5, cex.axis = 1.5, col = cols[coli])
    abline(h=0.2,v=0.8,col="black")
    # dev.off()
    }
}
```

```{r eval=F}
#WGCNA标配热图
#pdf('Fig8.Network.heatmap.pdf',width=35,height = 35)
# png('Fig8.Network.heatmap.png',width=1500,height = 1500)
plotTom <- dissTOM^7
save(plotTom,file='plotTom.Rdata')
color.key <- c('turquoise','orange','lemonchiffon')
mycol =  colorRampPalette(color.key)(200)
TOMplot(plotTom,geneTree,moduleColors,col=mycol,main="Network heapmap of selected gene")
# dev.off()
```



```{r}
###输出每个模块的基因
for (mod in 1:nrow(table(moduleColors)))
{  
  modules = names(table(moduleColors))[mod]
  probes = colnames(dataExpr)
  inModule = (moduleColors == modules)
  modGenes = probes[inModule]
  write.table(modGenes, file =paste0('Result/2.WGCNA/WGCNA.',modules,".txt"),sep=",",row.names=F,col.names=F,quote=F)
}

###输出GS_MM数据
probes = colnames(dataExpr)
geneInfo0 = data.frame(probes= probes,
                       moduleColor = moduleColors)
for (Tra in 1:ncol(geneTraitSignificance))
{
  oldNames = names(geneInfo0)
  geneInfo0 = data.frame(geneInfo0, geneTraitSignificance[,Tra],
                         GSPvalue[, Tra])
  names(geneInfo0) = c(oldNames,names(geneTraitSignificance)[Tra],
                       names(GSPvalue)[Tra])
}

for (mod in 1:ncol(geneModuleMembership))
{
  oldNames = names(geneInfo0)
  geneInfo0 = data.frame(geneInfo0, geneModuleMembership[,mod],
                         MMPvalue[, mod])
  names(geneInfo0) = c(oldNames,names(geneModuleMembership)[mod],
                       paste0('p.',names(MMPvalue)[mod]))
}
geneOrder =order(geneInfo0$moduleColor)
geneInfo = geneInfo0[geneOrder, ]
write.table(geneInfo, file = "Result/2.WGCNA/GS_MM.csv",sep=",",row.names=F)
```

下图展示了与各疾病性状相关的turquoise模块的基因significance。

```{r,fig.cap = '<div class="legend">**图8. 与疾病性状相关的turquoise模块的基因significance**<br> </div>' ,fig.width=12,fig.height=8,fig.align='center'}
if(save.fig == T){
  for (i in colnames(dataTraits)) {
    y <- dataTraits[, i]
    GS <- as.numeric(cor(y ,dataExpr, use="p"))
    GSPvalue = as.data.frame(corPvalueStudent(as.matrix(GS), nSamples))
    # write.table(GS,'Group/CK_GS.xls',sep="\t",quote=F)
    # write.table(GSPvalue,'Group/CK_GSPvalue.xls',sep="\t",quote=F)
    GeneSignificance <-  abs(GS)
    ModuleSignificance <- tapply(GeneSignificance,moduleColors, mean, na.rm=T)
    pdf(file = paste0("Result/2.WGCNA/图8. 与",i,"相关的turquoise模块的基因significance.pdf"), width = 8 , height = 6)
    par(mar = c(6, 5, 1, 1))
    plotModuleSignificance(GeneSignificance, moduleColors,las=2)
    dev.off()
  }
}else{
  par(mfrow=c(3,3))
  for (i in colnames(dataTraits)) {
    y <- dataTraits[, i]
    GS <- as.numeric(cor(y ,dataExpr, use="p"))
    GSPvalue = as.data.frame(corPvalueStudent(as.matrix(GS), nSamples))
    # write.table(GS,'Group/CK_GS.xls',sep="\t",quote=F)
    # write.table(GSPvalue,'Group/CK_GSPvalue.xls',sep="\t",quote=F)
    GeneSignificance <-  abs(GS)
    ModuleSignificance <- tapply(GeneSignificance,moduleColors, mean, na.rm=T)
    # pdf(file = paste0("Result/2.WGCNA/图12. 与",i,"相关的不同模块的基因significance.pdf"), width = 8 , height = 6)
    par(mar = c(6, 5, 1, 1))
    plotModuleSignificance(GeneSignificance, moduleColors,las=2)
    # dev.off()
  }
}
```



接着，我们从turquoise模块中进一步筛选基因，将与turquoise模块相关性大于0.8，p值小于0.05且与需满足至少与疾病状态或疾病进展状态的相关性大于0.2的基因选择为hub基因，该部分基因共包含645个基因。

```{r}
modules = 'turquoise'
probes = colnames(dataExpr)
inModule = (moduleColors == modules)
modGenes = probes[inModule]
genewithturquoise <- geneInfo[which(geneInfo$probes %in% modGenes),c(colnames(geneInfo)[1:20],'MEturquoise','p.MEturquoise')]
genewithturquoise <- genewithturquoise[which(abs(genewithturquoise$MEturquoise) > 0.8 & genewithturquoise$p.MEturquoise < 0.05),]
genewithturquoise <- genewithturquoise[which(rowSums(abs(genewithturquoise[,seq(3,7,2)])>0.2)>0),]
write.table(genewithturquoise, file =paste0('Result/2.WGCNA/WGCNA ',modules,"cor and pvalue 以MM 0.8 GS 0.2筛选后剩余基因.txt"),sep="\t",row.names=F,col.names=T,quote=F)
```

## 2.2 差异分析

```{r}
dir.create('Result/3.差异分析')
load('GSE124685.rda')
group <- ifelse(GSE124685pdata$DISEASE == 'CONTROL','Control','IFP')

DEGAll <- DEGlimma(GSE124685rnaCounts,group = group,ref = 'Control')
DEGAll <- DEGAll[order(DEGAll$logFC),]
deall <- DEGAll[which(DEGAll$PValue <= 0.05 & abs(DEGAll$logFC) > 0.5),]
deall.GSE124685 <- deall
up <- deall[which(deall$logFC >0),]
down <- deall[which(deall$logFC <0),]
write.csv(up,file = paste0('Result/3.差异分析/GSE124685 DEGs up .csv'))
write.csv(down,file = paste0('Result/3.差异分析/GSE124685 DEGs down .csv'))

write.csv(DEGAll,file = paste0('Result/3.差异分析/GSE124685 DEGs all.csv'))
write.csv(deall,file = paste0('Result/3.差异分析/GSE124685 DEGs sig .csv'))

```


为了探索IFP样本和正常样本之间特异性的差异基因，我们使用limma包比较样本两个组间的genes表达水平差异性。以p值小于0.05且abs(log2FC)大于等于0.5作为条件筛选出基因作为差异基因，IFP样本比正常样本共有`r nrow(deall.GSE124685)` 个差异基因，其中上调`r nrow(deall.GSE124685[which(deall.GSE124685$logFC >0),])`个（IFP样本比正常样本上调），下调`r nrow(deall.GSE124685[which(deall.GSE124685$logFC <0),])`个（IFP样本比正常样本下调）。


热图是对实验数据分布情况进行分析的直观可视化方法，可以用来进行实验数据的质量控制和直观展示重点研究对象的表达量数据差异变化情况，还可以对数据和样品进行聚类，观测样品质量。它有多种形式，但基本的元素却是通用的。如图9所示，热图展示了差异表达的基因在IFP样本比正常样本中的表达情况。
<br>

```{r ,fig.cap='<div class="legend">**图9. 差异表达基因热图可视化**<br>  每个小方格表示每个基因，其颜色表示该基因表达量大小，表达量越大颜色越深（红色为上调，蓝色为下调）。每行表示每个基因在不同样本中的表达量情况，每列表示每个样品中所有基因的表达量情况。左侧树状图表示对来自不同样本的不同基因的聚类分析结果。 </div>',fig.width= 8,fig.height= 8,fig.align='center'}
if(save.fig == T){
  pdf(file = paste0('Result/3.差异分析/图9. 差异表达基因热图可视化.pdf'),width = 10,height = 8)
  print(HeatmapPlot(deall,GSE124685rnaCounts,group) )
  dev.off()
}else{
   HeatmapPlot(DEGsig=deall,exprdata=GSE124685rnaCounts,group=group) 
}
```

火山图用于展示差异表达基因的差异倍数和显著性，图5为差异表达分析火山图。
<br>

```{r ,fig.cap='<div class="legend">**图10. 差异基因火山图**<br>  图中蓝色的点代表下调差异表达基因，红色的点代表上调差异表达基因，灰色为不具有显著统计学意义的基因。每一个点表示一个基因，横坐标轴为基因在两组样本间表达量差异倍数的对数值（Log2 Fold Change），越偏离中心差异倍数越大；纵坐标轴表示基因表达量变化的统计学显著性的负对数值（-log10（PValue）），值越大则表示差异越显著。横向虚线是-log10（PValue） = -log10(0.05)，纵向虚线是 log2（Fold Change） = 0.05。一般横轴越偏离中心的点其纵轴值也会比较大，因此呈现火山喷发的形状。 </div>',fig.width= 10,fig.height= 8,fig.align='center'}
if(save.fig == T){
  pdf(file = paste0('Result/3.差异分析/图10. 差异基因火山图.pdf'),width = 10,height = 8)
  print(VolcanoPlot(DEGAll,fc=2**0.5))
  dev.off()
  }else{
    VolcanoPlot(DEGAll,fc=2**0.5)
}
  
```
## 2.3 交集基因

```{r}
intersection <- intersect(deall$Gene.symbol,as.character(genewithturquoise$probes))
```

将wgcna筛选得到的关键模块基因和差异基因区交集，结果如下图所示，交集基因共有35个，分别是`r {intersection}`。


<center>![output](/data/project-yjh/IFP/Result/4. 差异基因和模块基因的交集/差异基因与关键模块基因交集.png)</center>
<center>**图11. 差异基因与关键模块基因交集**<br> </center>


## 2.4 富集分析

```{r}
dir.create('Result/5.富集分析')
tmppath <- paste0('Result/5.富集分析')
```


  本项目使用R软件clusterProfiler包进行基于GO和KEGG的富集分析，寻找各交集基因内大量基因共同的功能及相关通路。使用统计学方法累计超几何分布分析一组基因在某个功能结点上是否过出现（over-presentation），其计算公式如下：
  
<center>![](/data/project-yjh/04.LIHC_dissertation/Result/4.Enrichment/enrichment.jpg)</center>

  其中N为注释系统中基因的总数，n为要考察的结点或通路本身所注释的基因数，M为差异表达基因集大小，x为基因集与结点或通路的交集数目。

基因本体论(Gene ontology，GO)系统包括三个部分：生物学过程（biological process，BP）、分子功能（molecular functions，MF）、细胞组分（cellular components，CC）。京都基因与基因组百科全书（KEGG）是了解高级功能和生物系统（如细胞、 生物和生态系统），从分子水平信息，尤其是大型分子数据集生成的基因组测序和其他高通量实验技术的实用程序数据库资源，由日本京都大学生物信息学中心的Kanehisa 实验室于 1995 年建立，是国际最常用的生物信息数据库之一，以“理解生物系统的高级功能和实用程序资源库”著称。



```{r}
KEGGEnrichrev <- function(gene,prefix = '',path) {

  message ('### This step may take a few minutes ###\n')
  Path<-paste0(path,'/',prefix,'/')
  if (!file.exists(Path)){
    dir.create(Path)
  }
  genes <- biotype[match(gene, biotype$ensemblID),]
  genes <- genes[! is.na(genes$entrezgene),]
  universe <- biotype[!is.na(biotype$entrezgene),]

  kegg <- clusterProfiler::enrichKEGG(gene = as.character(genes$entrezgene),
                     organism = 'hsa',
                     universe = as.character(unique(
                       universe$entrezgene[!is.na(universe$entrezgene)])),
                     minGSSize = 2,
                     maxGSSize = 500,
                     pAdjustMethod = 'fdr')

  kegg <- data.frame(kegg@result)

  kegg$geneID <- unlist(lapply(kegg$geneID, function(v)
    paste(genes$ensemblID[match(strsplit(v, '/', fixed=TRUE)[[1]],
                                genes$entrezgene)], collapse = '/')))
  kegg <- organizeEnrichFun(kegg)
  message ('KEGG analysis done!')

  write.csv(kegg, file = paste0(Path,prefix,'_AllenrichKEGG.csv'),row.names=F)
  return(kegg)
}

organizeEnrichFun <- function(go) {

    Terms <- paste(go$ID, go$Description, sep='~')
    Counts <- go$Count
    
    GeneRatio <- go$GeneRatio
    BgRatio <- go$BgRatio
    
    pValue <- go$pvalue
    FDR <- go$p.adjust
    
    listTotal <- vapply(go$GeneRatio, function(v) 
        convertRatioFun(v, type='bg'), numeric(1))
    popHits <- vapply(go$BgRatio, function(v) 
        convertRatioFun(v, type='hit'), numeric(1))
    popTotal <- vapply(go$BgRatio, function(v) 
        convertRatioFun(v, type='bg'), numeric(1))
    
    foldEnrichment <- as.vector(Counts/listTotal*popTotal/popHits)
    
    geneID <- go$geneID
    geneSymbol <- unlist(lapply(strsplit(geneID, '/', fixed=TRUE), 
        function(v) paste(ensembl2symbolFun(v), collapse = '/')))
    
    goOutput <- data.frame(Terms, Counts, GeneRatio, BgRatio, pValue, FDR, 
        foldEnrichment, geneID, geneSymbol)
    
    return (goOutput)
}
convertRatioFun <- function(v, type='bg') {
    ratio <- strsplit(v, '/', fixed=TRUE)
    
    if (type=='bg') {
        num <- as.numeric(as.character(ratio[[1]][2]))
    } else if (type=='hit') {
        num <- as.numeric(as.character(ratio[[1]][1]))
    }
    
    return (num)
}
ensembl2symbolFun <- function(ensemblID, info='symbol') {
    geneInfo <- biotype[match(ensemblID, biotype$ensemblID),]
    geneSymbol <- geneInfo$geneSymbol
    
    if (info=='symbol') {
        return (geneSymbol)
    } else if (info=='all') {
        return (geneInfo)
    }
}


symbol2ensemblFun <- function(symbol, info='ensemblID') {
    geneInfo <- biotype[match(symbol, biotype$geneSymbol),]
    ensemblID <- geneInfo$ensemblID
    
    if (info=='ensemblID') {
        return (ensemblID)
    } else if (info=='all') {
        return (geneInfo)
    }
}
KEGGplotsrev <- function(kegg, type='bar',num.terms=10,w=0,h=0,
                    prefix='',path,save=FALSE,outpdf=FALSE) {

  if (is.logical(save) && (length(save) != 1L || is.na(save)))
    stop("'save' must be 'TRUE', 'FALSE'")
  issave <- if (is.logical(save))
    save
  else TRUE

  if (is.logical(outpdf) && (length(outpdf) != 1L || is.na(outpdf)))
    stop("'outpdf' must be 'TRUE', 'FALSE'")
  issave <- if (is.logical(outpdf))
    outpdf
  else TRUE

  outpath <- paste0(path,'/',prefix,'/')
  if(!file.exists(outpath)) dir.create(outpath)

  if (unique(substr(kegg$Terms,1,4))=="DOID"){
    tifname<-paste(outpath,prefix,"_enrichDO_",type,".tif",sep="")
    outtable <-paste0(outpath,prefix,"_enrichDOplot.csv")
  }
  else {
    tifname<-paste(outpath,prefix,"_enrichKEGG_",type,".tif",sep="")
    outtable <-paste0(outpath,prefix,"_enrichKEGGplot.csv")
  }
  
  if (nrow(kegg) > num.terms) {
    kegg <- kegg[seq_len(num.terms),]
  }
  kegg <- kegg[order(kegg[,'FDR']),]
  kegg[,'Terms'] <- factor(kegg[,'Terms'],levels = kegg[,'Terms'])
  outw<-kegg[,c('Counts','pValue','FDR')]
  outw$ID<-substring(kegg$Terms,1,8)
  outw$Description<-substring(kegg$Terms,10)
  outw<-outw[,c('ID','Description','Counts','pValue','FDR')]
  write.csv(outw,file = outtable,row.names = F)

  sz = 20 #plot size
  if (type=='bubble') {

    keggBasic = ggplot(data=kegg, mapping=aes(x=Terms,
                                              y=foldEnrichment,color=FDR,size=Counts))
    KEGGP<-keggBasic+geom_point()+ coord_flip() +
        scale_x_discrete(limits=rev(kegg$Terms)) +
        scale_colour_gradientn(colors= c("red","green")) +
        xlab('')+ylab('Fold enrichment') +
        guides(shape = guide_legend(order=1),
               colour = guide_colourbar(order=2)) +
        theme_bw()+theme(axis.line = element_line(colour = "black"),
                         panel.grid.minor = element_blank(),
                         panel.border = element_rect(colour='black'),
                         panel.background = element_blank()) +
        ggtitle("") + theme(plot.title = element_text(hjust = 0.5, size=20)) +
        theme(axis.text.y=element_text(size=sz),
              axis.title=element_text(size=sz),
              axis.text.x=element_text(size=sz)) +
        theme(legend.text = element_text(size = sz),
              legend.title = element_text(size = sz)) +
        theme(strip.text = element_text(size = sz),
              legend.key.size = unit(0.8,'cm'))

  }
  else if (type=='bar') {
    kegg$logFDR <- -log10(kegg$FDR)
    keggBasic = ggplot(data=kegg, mapping=aes(x=Terms, y=-log(FDR,10),fill=FDR))
    KEGGP<-keggBasic + geom_bar(stat='identity') +
      scale_fill_continuous(low="orangered", high="darkgreen", space='rgb') +
      ylim(0, max(-log(kegg$FDR,10))) +
      theme(legend.title=element_blank())+ylab('-log10(FDR)')+
      xlab('') + coord_flip() +
      theme_bw()+theme(axis.line = element_line(colour = "black"),
                       panel.grid.major = element_blank(),
                       panel.grid.minor = element_blank(),
                       panel.border = element_rect(colour='white'),
                       panel.background = element_blank()) +
      theme(axis.text.y=element_text(size=sz),
            axis.title=element_text(size=sz),
            axis.text.x=element_text(size=sz)) +
      guides(shape = guide_legend(order=1),
               colour = guide_colourbar(order=2)) +
      theme(legend.text = element_text(size = sz),
              legend.title = element_text(size = sz)) +
        theme(strip.text = element_text(size = sz),
              legend.key.size = unit(0.8,'cm'))
  }
  if (issave==TRUE) {
    tiff(file=tifname,width=300+w, height=200+h, units='mm',res=400)
    print(KEGGP)
    dev.off()
    if(outpdf==TRUE){
      pdf(gsub('tif','pdf',tifname),width=12+w, height=8+h)
      print(KEGGP)
      dev.off()
    }
  }
  else {
    KEGGP
  }
}
GOEnrichrev <- function(gene, simplify=TRUE, level=0, prefix='',path) {

  message ('### This step may take a few minutes ###\n')
  Path<-paste0(path,'/',prefix,'/')
  if (!file.exists(Path)){
    dir.create(Path)
  }
  goBP <- enrichGO(gene = gene,
                   universe = biotype$ensemblID,
                   OrgDb = org.Hs.eg.db,
                   ont = "BP",
                   keyType = 'ENSEMBL',
                   pAdjustMethod = "fdr",
                   readable = FALSE,
                   minGSSize = 2,
                   qvalueCutoff =1)

  if (level != 0) {
    goBP <- gofilter(goBP, level=level)
  }

  if (simplify==TRUE) {
    goBP <- clusterProfiler::simplify(goBP, cutoff=0.7, by="p.adjust", select_fun=min)
  }

  message ('BP analysis done!')

  goCC <- enrichGO(gene = gene,
                   universe = biotype$ensemblID,
                   OrgDb = org.Hs.eg.db,
                   ont = "CC",
                   keyType = 'ENSEMBL',
                   pAdjustMethod = "fdr",
                   readable = FALSE,
                   minGSSize = 2,
                   qvalueCutoff =1)

  if (level != 0) {
    goCC <- gofilter(goCC, level=level)
  }

  if (simplify==TRUE) {
    goCC <- clusterProfiler::simplify(goCC, cutoff=0.7, by="p.adjust", select_fun=min)
  }

  message ('CC analysis done!')

  goMF <- enrichGO(gene = gene,
                   universe = biotype$ensemblID,
                   OrgDb = org.Hs.eg.db,
                   ont = "MF",
                   keyType = 'ENSEMBL',
                   pAdjustMethod = "fdr",
                   readable = FALSE,
                   minGSSize = 2,
                   qvalueCutoff =1)

  if (level != 0) {
    goMF <- gofilter(goMF, level=level)
  }

  if (simplify==TRUE) {
    goMF <- clusterProfiler::simplify(goMF, cutoff=0.7, by="p.adjust", select_fun=min)
  }


  goBP <- organizeEnrichFun(data.frame(goBP@result))
  goCC <- organizeEnrichFun(data.frame(goCC@result))
  goMF <- organizeEnrichFun(data.frame(goMF@result))
  message ('MF analysis done!')

  # write.table(goBP, file = paste0(Path,gene.type,'_AllEnrichGOBP.txt'),sep="\t",quote=F,row.names=F)
  # write.table(goCC, file = paste0(Path,gene.type,'_AllEnrichGOCC.txt'),sep="\t",quote=F,row.names=F)
  # write.table(goMF, file = paste0(Path,gene.type,'_AllEnrichGOMF.txt'),sep="\t",quote=F,row.names=F)

  enrichOutput <- data.frame(rbind(goBP, goCC, goMF))
  enrichOutput$Category <- rep(c('GO_BP','GO_CC','GO_MF'),c(nrow(goBP),nrow(goCC),nrow(goMF)))
  write.csv(enrichOutput,file = paste0(Path,prefix,'_AllenrichGO.csv'),row.names = F)

  return (enrichOutput)
}
GOplotsrev <- function(enrichment, type='bar',num.terms=10,axis='all',prefix=prefix,path=tmppath,w=0,h=0,save=FALSE,outpdf=FALSE) {

  if (is.logical(save) && (length(save) != 1L || is.na(save)))
    stop("'save' must be 'TRUE', 'FALSE'")
  issave <- if (is.logical(save))
    save
  else TRUE
  if (is.logical(outpdf) && (length(outpdf) != 1L || is.na(outpdf)))
    stop("'outpdf' must be 'TRUE', 'FALSE'")
  issave <- if (is.logical(outpdf))
    outpdf
  else TRUE

  outpath <- paste0(path,'/',prefix,'/')
  if(!file.exists(outpath))
    dir.create(outpath)

  goBP <- enrichment[enrichment$Category=='GO_BP',]
  goCC <- enrichment[enrichment$Category=='GO_CC',]
  goMF <- enrichment[enrichment$Category=='GO_MF',]

  if (nrow(goBP) > num.terms) {
    goBP <- goBP[seq_len(num.terms),]
  }

  if (nrow(goCC) > num.terms) {
    goCC <- goCC[seq_len(num.terms),]
  }

  if (nrow(goMF) > num.terms) {
    goMF <- goMF[seq_len(num.terms),]
  }

  go <- rbind(goBP, goCC, goMF)

  outw<-go[,c('Counts','pValue','FDR','Category')]
  outw$ID<-substring(go$Terms,1,10)
  outw$Description<-substring(go$Terms,12)
  outw<-outw[,c('ID','Description','Counts','pValue','FDR','Category')]
  write.csv(outw,file = paste0(outpath,prefix,'_enrichGOplot.csv'),
              row.names = F)
  if(axis=='description'){
    go$Terms<-substring(go$Terms,12)
  }
  if(axis=='term'){
    go$Terms<-substring(go$Terms,1,10)
  }

  sz <- 16

  if (type=='bubble') {

    go$Terms <- paste(go$Terms, '[', go$Category, ']', sep='')
    goBasic = ggplot(data=go, mapping=aes(x=Terms,
                      y=foldEnrichment,color=FDR,size=Counts))
    GOP<-goBasic+geom_point()+ coord_flip() +
        scale_x_discrete(limits=rev(go$Terms)) +
        scale_colour_gradientn(colors= c("red","green")) +
        xlab('')+ylab('Fold enrichment') +
        guides(shape = guide_legend(order=1),
               colour = guide_colourbar(order=2)) +
        theme_bw()+theme(axis.line = element_line(colour = "black"),
                         panel.grid.minor = element_blank(),
                         panel.border = element_rect(colour='black'),
                         panel.background = element_blank()) +
        ggtitle("") + theme(plot.title = element_text(hjust = 0.5, size=20)) +
        theme(axis.text.y=element_text(size=sz,colour = 'black'),
              axis.title=element_text(size=sz),
              axis.text.x=element_text(size=sz,colour = 'black')) +
        theme(legend.text = element_text(size = sz),
              legend.title = element_text(size = sz)) +
        theme(strip.text = element_text(size = sz),
              legend.key.size = unit(0.8,'cm'))

  }

  else if (type=='bar') {

    goBasic = ggplot(data=go, mapping=aes(x=Terms, y=-log(FDR,10),
                                              fill=Category))
    GOP<-goBasic + geom_bar(stat='identity') +
        scale_x_discrete(limits=rev(go$Terms)) +
        ylim(0, max(-log(go$FDR,10))) +
        theme(legend.title=element_blank())+
        ylab('-log10(FDR)')+xlab('') + coord_flip() +
        scale_fill_hue(name='',breaks=go$Category,
                       labels=go$Category) +
        theme_bw()+theme(axis.line = element_line(colour = "black"),
                         panel.grid.major = element_blank(),
                         panel.grid.minor = element_blank(),
                         panel.border = element_rect(colour='white'),
                         panel.background = element_blank()) +
        theme(axis.text=element_text(size=sz,colour = 'black'),
              axis.title=element_text(size=sz)) +
        theme(legend.text = element_text(size=sz))
  }
  if (issave==TRUE) {

    tifname<-paste(outpath,prefix,"_enrichGO_",type,".tif",sep="")
    tiff(file=tifname,width=360+w, height=240+h, units='mm',res=400)
    print(GOP)
    dev.off()
    if(outpdf==TRUE){
      pdf(gsub('tif','pdf',tifname),width=12+w, height=8+h)
      print(GOP)
      dev.off()
    }
  }
  else {
    GOP
  }
}
```

```{r}
GOCircleplot <- function(ego,geneList){
  ego <- ego
  if(grepl('^hsa',ego$Terms)){
  ego$ID <- unlist(sapply(ego$Terms,function(x) substr(x,1,8)))
  ego$Description <- unlist(sapply(ego$Terms,function(x) substr(x,10,str_length(x))))
  }else{
    ego$ID <- unlist(sapply(ego$Terms,function(x) substr(x,1,10)))
    ego$Description <- unlist(sapply(ego$Terms,function(x) substr(x,12,str_length(x))))
  }
  Circle=data.frame(Category = "ALL",ID = ego$ID,Term = ego$Description, Genes = gsub("/", ", ", ego$geneSymbol), adj_pval = ego$FDR)
  circ <- circle_dat(Circle, geneList)
  GOCircle(circ,rad1=2.5,rad2=3.5,label.size=4,nsub=10)  
}
GOHeatplot <- function(ego,geneList){
  termNum = 20                                     #ÏÞ¶¨termÊýÄ¿
  geneNum = nrow(geneList)                         #ÏÞ¶¨»ùÒòÊýÄ¿
  ego <- ego
  ego$ID <- unlist(sapply(ego$Terms,function(x) substr(x,1,10)))
  ego$Description <- unlist(sapply(ego$Terms,function(x) substr(x,12,str_length(x))))
  Circle=data.frame(Category = "ALL",ID = ego$ID,Term = ego$Description, Genes = gsub("/", ", ", ego$geneSymbol), adj_pval = ego$FDR)
  circ <- circle_dat(Circle, geneList)
  chord <- chord_dat(circ, geneList[1:geneNum,], Circle$Term[1:termNum])
  #pdf(file="KEGGHeat.pdf",width = 9,height = 5)
  GOHeat(chord, nlfc =1, fill.col = c('red', 'white', 'blue'))
  #dev.off()
}
```

```{r ,eval= F}
upgene <- bitr(genewithturquoise$probes,fromType = 'SYMBOL',toType = c('ENSEMBL','ENTREZID'),OrgDb = 'org.Hs.eg.db')
prefix <- 'intersection'
UpgeneGoOut<-GOEnrichrev(gene = upgene[,2],prefix = prefix,path = tmppath)
UpgeneGoOut$Terms <- as.character(UpgeneGoOut$Terms)
# UpgeneGoOut$Terms[389] <- 'GO:0016712~oxidoreductase activity, #'
GOplotsrev(UpgeneGoOut,type='bar',num.terms=10,axis = 'description',prefix=prefix,path=tmppath,save = T, outpdf = T,w = 1)
GOplotsrev(UpgeneGoOut,type='bubble',num.terms=10,axis = 'description',prefix=prefix,path=tmppath,save = T, outpdf = T,w = 1)

UpgeneKEGGOut <- KEGGEnrichrev(gene = upgene[,2],prefix = prefix,path = tmppath)
KEGGplotsrev(UpgeneKEGGOut,type='bar',num.terms=10,path= tmppath,prefix=prefix,save = T, outpdf = T,w = 1)
KEGGplotsrev(UpgeneKEGGOut,type='bubble',num.terms=10,path= tmppath,prefix=prefix,save = T, outpdf = T,w = 1)
```

交集基因富集分析统计学意义最显著的前10个GO条目信息见表2，前10个统计学意义最显著的KEGG条目信息见表3。

```{r}
prefix <- 'intersection'
UpgeneGoOut.top5 <- read.table(paste0('Result/5.富集分析/',prefix,'/',prefix,'_enrichGOplot.csv'),header = T,sep = ',')
UpgeneGoOut.top5 %>% kable("html",caption = '<center>**表2. 交集基因富集分析 GO注释（Top10）**</center>') %>%
  kable_styling(bootstrap_options = "striped", full_width = F)
write.csv(UpgeneGoOut.top5,file = paste0('Result/5.富集分析/',prefix,'/表2. 交集基因富集分析 GO注释（Top10）.csv'))
```
```{r}
UpgeneKEGGOut.top5 <- read.table(paste0('Result/5.富集分析/',prefix,'/',prefix,'_enrichKEGGplot.csv'),header = T,sep = ',')
UpgeneKEGGOut.top5 %>% kable("html",caption = '<center>**表3. 交集基因富集分析 KEGG注释（Top10）**</center>') %>%
  kable_styling(bootstrap_options = "striped", full_width = F)
write.csv(UpgeneKEGGOut.top5,file = paste0('Result/5.富集分析/',prefix,'/表3. 交集基因富集分析 KEGG注释（Top10）.csv'))
```

交集基因富集分析统计学意义最显著的GO条目和KEGG富集结果条形图及气泡图如图12和图13。以PDF小于0.05进行筛选，交集基因富集到了8条 GO Term。以Pvalue小于0.05进行筛选，交集基因富集到了7条KEGG通路。

```{r ,fig.cap='<div class="legend">**图12. 交集基因富集分析 GO注释可视化（Top10）（上为条形图，下为气泡图）**<br> 条形图的长度代表调整后的Pvalue（-log10(FDR)）的高低，条形图越长越显著，纵坐标代表每个 GO term。气泡图中横坐标代表基因比例，点的颜色代表 p 值，越红代表可信度越高，点的大小代表参与的基因数，点越大代表参与的基因数越多。</div>' ,fig.width= 13,fig.height= 10,fig.align='center'}
#setwd(paste0(path,'Result/5.富集分析'))
#UpgeneGoOut<-lncRNAtools::GOEnrich(gene = mirUpTargetgene, simplify = F,level = 4,gene.type = 'UP')
UpgeneGoOut <- read.table(paste0('Result/5.富集分析/',prefix,'/',prefix,'_AllenrichGO.csv'),header = T,sep = ',')
UpgeneGoOut$Terms <- as.character(UpgeneGoOut$Terms)
# UpgeneGoOut$Terms[389] <- 'GO:0016712~oxidoreductase activity, #'
if(save.fig == T){
  pdf(file = paste0('Result/5.富集分析/',prefix,'/','图12. 交集基因富集分析 GO注释可视化（Top10）（上为条形图，下为气泡图）-1.pdf'),width = 12,height = 8)
    print(GOplotsrev(UpgeneGoOut,type='bar',num.terms=10,axis = 'description',prefix=prefix,path=tmppath,save = F, outpdf = F,w = 1))
  dev.off()
  pdf(file = paste0('Result/5.富集分析/',prefix,'/','图12. 交集基因富集分析 GO注释可视化（Top10）（上为条形图，下为气泡图）-2.pdf'),width = 13,height = 8)
    print(GOplotsrev(UpgeneGoOut,type='bubble',num.terms=10,axis = 'description',prefix=prefix,path=tmppath,save = F, outpdf = F,w = 1))
  dev.off()
}else{
  print(GOplotsrev(UpgeneGoOut,type='bar',num.terms=10,axis = 'description',prefix=prefix,path=tmppath,save = F, outpdf = F,w = 1))
  print(GOplotsrev(UpgeneGoOut,type='bubble',num.terms=10,axis = 'description',prefix=prefix,path=tmppath,save = F, outpdf = F,w = 1))
}
```

```{r ,fig.cap='<div class="legend">**图13. 交集基因富集分析 KEGG注释可视化（Top10）（上为条形图，下为气泡图）**<br> 条形图的长度代表调整后的Pvalue（-log10(FDR)）的高低，条形图越长越显著，纵坐标代表每个 KEGG通路，条形图的颜色表示FDR，颜色越深越可信。气泡图中横坐标代表基因比例，点的颜色代表 p 值，越红代表可信度越高，点的大小代表参与的基因数，点越大代表参与的基因数越多。</div>' ,fig.width= 14,fig.height= 12,fig.align='center'}
### KEGG
#UpgeneKEGGOut<-KEGGEnrich(gene = mirUpTargetgene,gene.type = 'UP')
UpgeneKEGGOut <- read.table(paste0('Result/5.富集分析/',prefix,'/',prefix,'_AllenrichKEGG.csv'),header = T,sep = ',')

if(save.fig == T){
  pdf(file = paste0('Result/5.富集分析/',prefix,'/','图13. 交集基因富集分析 KEGG注释可视化（Top10）（上为条形图，下为气泡图）-1.pdf'),width = 12,height = 8)
    print(KEGGplotsrev(UpgeneKEGGOut,type='bar',num.terms=10,path= tmppath,prefix=prefix,save = F, outpdf = F,w = 1))
  dev.off()
  pdf(file = paste0('Result/5.富集分析/',prefix,'/','图13. 交集基因富集分析 KEGG注释可视化（Top10）（上为条形图，下为气泡图）-2.pdf'),width = 12,height = 8)
    print(KEGGplotsrev(UpgeneKEGGOut,type='bubble',num.terms=10,path= tmppath,prefix=prefix,save = F, outpdf = F,w = 1))
  dev.off()
}else{
  print(KEGGplotsrev(UpgeneKEGGOut,type='bar',num.terms=10,path= tmppath,prefix=prefix,save = F, outpdf = F,w = 1))
  print(KEGGplotsrev(UpgeneKEGGOut,type='bubble',num.terms=10,path= tmppath,prefix=prefix,save = F, outpdf = F,w = 1))
}
```

## 2.5 免疫浸润分析

```{r eval=F}
immune <- read.table('xCell_GSE124685rawdata.txt',sep = '\t',header = T)
```


### 2.5.1 ssGSEA推算免疫浸润

ssGSEA——单样本GSEA的方法，通过这个方法，我们可以得到每个样本的免疫细胞或者免疫功能，免疫通路的活性，然后根据免疫活性进行分组。ssGSEA(single sample GSEA)主要针对单样本无法做GSEA而提出的一种实现方法，原理上与GSEA是类似的。ssGSEA根据表达谱文件计算每个基因的rank值，再进行后续的统计分析。

运用24个免疫相关的基因集，这24个基因集不仅包括免疫细胞种类，还包括免疫相关的通路、免疫相关的功能，这些免疫相关的基因集内容是非常丰富的。用这些免疫相关的基因集做分析，就可以得到每个样本的免疫活性。另外，成纤维细胞和肌成纤维细胞也是IFP进展的一个重要特征，然而现有的一些推算免疫浸润的方法中，xcell和MCPcount只能推算成纤维免细胞的比例，其他算法无法推算肌成纤维细胞的比率，再次我们参照SSgsea的方式，将IFP单细胞分析文章（ https://pubmed.ncbi.nlm.nih.gov/32832599/ ）中的成纤维细胞和肌成纤维细胞marker genes制作为基因集，以此来推算IFP组织中的成纤维细胞和肌成纤维细胞的细胞成分。

其中成纤维细胞基因集包含有基因：PDGFRB、CD34、FBN1、FBLN2、VIT、HAS1、HAS2、FBN1、CXCL14、COL1A1、COL1A2、COL3A1、FN1、FBN1、HAS1、HAS2、GALNT1、GALNT17、R0R1和R0R2。

肌成纤维细胞基因集包含有基因：PDGFRB、 MYLK、NEBL、MYO10、MYO1D、RYR2、ITGA8 、ACTA2、COL1A1、COL3A1、COL5A1、COL6A1、COL8A1、PDGFC、COL16A1、COL10A1、COL7A1、TWIST1、MMP14、MMP11和MMP13。

下图展示了各免疫基因集的免疫评分。 

```{r}
dir.create('Result')
dir.create('Result/6.ssGSEA')

# gene_set<- read.table('/data/project-yjh/20.YQB003动脉粥样硬化/mmc3.txt',sep = '\t',
#                     header = T)##读取已经下载好的免疫细胞和对应基因列表，来源见文献附件
load('/data/project-yjh/39.yq123BRCA/DATA/easy_input_immunity.symbol.rdata')

immunity[['Fibroblasts']] <- c('PDGFRB','CD34','FBN1','FBLN2','VIT','HAS1','HAS2','FBN1','CXCL14','COL1A1','COL1A2','COL3A1','FN1','FBN1','HAS1','HAS2','GALNT1','GALNT17','R0R1','R0R2')

immunity[['Myofibroblasts']] <- c('PDGFRB','MYLK','NEBL','MYO10','MYO1D','RYR2','ITGA8 ','ACTA2','COL1A1','COL3A1','COL5A1','COL6A1','COL8A1','PDGFC','COL16A1','COL10A1','COL7A1','TWIST1','MMP14','MMP11','MMP13')
```


```{r eval=F}
gsva_matrix <- gsva(as.matrix(GSE124685rnaCounts), immunity,method='ssgsea',kcdf='Gaussian',abs.ranking=TRUE)
write.table(gsva_matrix,file = 'Result/6.ssGSEA/LIHC ssGSEA推算.csv',quote = F,sep = ',')

colnames(gsva_matrix) <- as.character(vapply(colnames(gsva_matrix), function(v) substr(v, 1, 12), character(1)))
#save(gsva_matrix,file='ssGSEA.rda')
```

```{r}
load('GSE124685.rda')
sz=15
dataTraits4immu <- as.data.frame(GSE124685pdata[,c(2:3,6:9)])
colnames(dataTraits4immu) <- c("DISEASE","IFPType","PKYR","FEV1pp","FVCpp","DLCOpp")
dataTraits4immu$IFPType <- factor(dataTraits4immu$IFPType,levels = c('IPF1', 'IPF2', 'IPF3','CONTROL'))
```


```{r fig.cap='<div class="legend">**图14. ssGSEA推算**<br> </div>',fig.width= 10,fig.height= 9,fig.align='center'}
# load('genemodel.dataTraits4immu.rda')
load('ssGSEA.rda')
gsva_matrix1<- t(scale(t(gsva_matrix)))#归一化
gsva_matrix1[gsva_matrix1< -2] <- -2
gsva_matrix1[gsva_matrix1>2] <- 2
anti_tumor <- c('Activated CD4 T cell', 'Activated CD8 T cell', 'Central memory CD4 T cell', 'Central memory CD8 T cell', 'Effector memeory CD4 T cell', 'Effector memeory CD8 T cell', 'Type 1 T helper cell', 'Type 17 T helper cell', 'Activated dendritic cell', 'CD56bright natural killer cell', 'Natural killer cell', 'Natural killer T cell')
pro_tumor <- c('Regulatory T cell', 'Type 2 T helper cell', 'CD56dim natural killer cell', 'Immature dendritic cell', 'Macrophage', 'MDSC', 'Neutrophil', 'Plasmacytoid dendritic cell')
anti<- gsub('^ ','',rownames(gsva_matrix1))%in%anti_tumor
pro<- gsub('^ ','',rownames(gsva_matrix1))%in%pro_tumor
non <- !(anti|pro)##设定三种基因
gsva_matrix1<- rbind(gsva_matrix1[anti,],gsva_matrix1[pro,],gsva_matrix1[non,])#再结合起来，使图分成三段
normalization<-function(x){
  return((x-min(x))/(max(x)-min(x)))}#设定normalization函数
nor_gsva_matrix1 <- normalization(gsva_matrix1)
nor_gsva_matrix1 <- nor_gsva_matrix1[,match(rownames(dataTraits4immu),colnames(nor_gsva_matrix1))]

annotation_col = dataTraits4immu

rownames(annotation_col) <- colnames(nor_gsva_matrix1)#使编号能互相对应
bk = unique(c(seq(0,1, length=100)))#设定热图参数
if(save.fig == T){
  pdf(file = paste0('Result/6.ssGSEA','/图14. ssGSEA推算-1.pdf'),width= 20,height= 16)
  pheatmap(nor_gsva_matrix1,
           show_colnames = F,
           cluster_rows = F,cluster_cols = T,
           annotation_col = annotation_col,
           breaks=bk,
           fontsize=15,gaps_row = c(12,20))
  dev.off()
  pdf(file = paste0('Result/6.ssGSEA','/图14. ssGSEA推算-2.pdf'),width= 20,height= 16)
  loc <- order(annotation_col$IFPType,colSums(nor_gsva_matrix1))
  # loc <- c(loc[-(1:35)],loc[1:35])
  pheatmap(nor_gsva_matrix1[,loc],
           show_colnames = F,
           cluster_rows = F,cluster_cols = F,
           annotation_col = annotation_col[loc,],
           breaks=bk,
           fontsize=15,gaps_row = c(12,20))
  dev.off()
}else{
  loc <- order(annotation_col$IFPType,colSums(nor_gsva_matrix1))
  # loc <- c(loc[-(1:35)],loc[1:35])
  pheatmap(nor_gsva_matrix1[,loc],
           show_colnames = F,
           cluster_rows = F,cluster_cols = F,
           annotation_col = annotation_col[loc,],
           breaks=bk,
           fontsize=15,gaps_row = c(12,20))
}
```

### 2.5.2 比较不同进展组间的免疫细胞的差异

我们随后比较了不同进展组间的免疫细胞基因集富集分数之间的差异，从下图中可以看出在多个免疫细胞相关的基因集中高低风险组表现出明显的差异。


```{r  ,fig.cap='<div class="legend">**图49. 免疫细胞在两种亚型中浸润差异分析_箱线图**<br> </div>',fig.width=12,fig.height=8,fig.align='center'}
#identical(rownames(CIBERSORT.filter),rownames(CIBERSORT.filter))

# load('genemodel.dataTraits4immu.rda')
load('ssGSEA.rda')
gsva_matrix <- gsva_matrix[,match(rownames(dataTraits4immu),colnames(gsva_matrix))]
CIBERSORT.filter<- scale(t(gsva_matrix))#归一化
Type = data.frame(IFPType = dataTraits4immu$IFPType)
rownames(Type)=rownames(CIBERSORT.filter)
write.table(Type,file = 'Result/6.ssGSEA/IFP 样本信息.xls',sep = '\t')

boxdata <- lapply(colnames(CIBERSORT.filter), function(x) data.frame(expression=CIBERSORT.filter[,x],gene=rep(x,nrow(CIBERSORT.filter)),group=Type$IFPType))
boxdata <- do.call(rbind,boxdata)
boxdata$group <- factor(boxdata$group,levels = c('CONTROL','IPF1', 'IPF2', 'IPF3'))
p <-  ggboxplot(boxdata, x="gene", y="expression", color = "group", 
            ylab="Fraction",  xlab="", palette = 'nejm',add = "jitter",size = 1,axis.line =2)+
    theme(axis.text.y=element_text(size=sz),
                axis.title=element_text(size=sz),
                axis.text.x=element_text(size=sz)) +
          theme(legend.text = element_text(size = sz),
                legend.title = element_text(size = sz)) +
            stat_compare_means(label = "p.signif",label.y = 1.05*max(boxdata[,1]),aes(group=boxdata$group))+
            rotate_x_text(60)


if(save.fig == T){
  pdf(file = paste0('Result/6.ssGSEA',"/图15. 免疫细胞在不同进展期浸润差异分析_箱线图.pdf"),height=6,width=12)
  print(p)
  #colnames(CIBERSORT.filter)[c(4,12,18)]
  dev.off()
}else{
  print(p)
}
```
### 2.5.3 计算关键基因与各免疫细胞的相关性

```{r}
hubexp <- data.frame(GSE124685rnaCounts[intersection,])
hubcell <- data.frame(gsva_matrix)

```


```{r}
dir.create('Result/6.ssGSEA')
plotdata <- merge(t(hubexp),t(hubcell),by=0)
rownames(plotdata) <- plotdata[,1]
plotdata <- plotdata[,-1]
# plotdata <- plotdata[,c('Myofibroblasts','Fibroblasts',intersection)]
```

```{r eval=F}
library(PerformanceAnalytics)#加载包
# plotdata <- plotdata[,c(c('Myofibroblasts','Fibroblasts'),intersection)]
# pdf(paste0('Result/6.ssGSEA/特征基因交集单基因与疾病性状的相关性.pdf'))
chart.Correlation(plotdata, histogram=TRUE, pch=1,cex=1.5)
# dev.off()
```
```{r}

library(Hmisc)#加载包
res <- rcorr(as.matrix(plotdata))
flattenCorrMatrix <- function(cormat, pmat) {
  ut <- upper.tri(cormat) 
  data.frame( row = rownames(cormat)[row(cormat)[ut]], 
  column = rownames(cormat)[col(cormat)[ut]], cor =(cormat)[ut], p = pmat[ut],stringsAsFactors = F)
}
#举个栗子
data <- flattenCorrMatrix(res$r, res$P)
data <- data[-which(data$row %in% intersection & data$column %in% intersection),]
data <- data[-which(data$row %in% rownames(gsva_matrix) & data$column %in% rownames(gsva_matrix)),]
data$pstar <- ifelse(data$p < 0.05,
                     ifelse(data$p < 0.01,"**","*"),
                     "")
data <- data[,c(2,1,3:5)]
colnames(data)[1:3] <- c('immune_cells', 'gene','cor')
write.csv(data,file = 'Result/6.ssGSEA/基因与免疫细胞的相关性.csv')
```


```{r figureLable,fig.cap = '<div class="legend">**图16. 特征基因交集单基因与疾病性状的相关性**<br> 每个小方格表示每个基因与免疫细胞的相关性（分别是横坐标和纵坐标），其颜色表示相关性大小，（正负）相关性越大颜色越深（红色为正相关，蓝色为负相关）。</div>' ,fig.width=14,fig.height=14,fig.align='center'}
g <- ggplot(data, aes(immune_cells, gene)) + 
  geom_tile(aes(fill = cor), colour = "white",size=1)+
  scale_fill_gradient2(low = "#2b8cbe",mid = "white",high = "#e41a1c")+
  geom_text(aes(label=pstar),col ="black",size = 7)+
  theme_minimal()+# 不要背景
  theme(axis.title.x=element_blank(),#不要title
        axis.ticks.x=element_blank(),#不要x轴
        axis.title.y=element_blank(),#不要y轴
        axis.text.x = element_text(angle = 45, hjust = 1,size = 22),# 调整x轴文字
        axis.text.y = element_text(size = 22))+#调整y轴文字
  #调整legen
  labs(fill =paste0(" * p < 0.05","\n\n","** p < 0.01","\n\n","Correlation"))

if(save.fig == T){
  pdf(paste0('Result/6.ssGSEA/图16.特征基因交集单基因与疾病性状的相关性.pdf'),width = 12,height = 12)
  print(g)
  dev.off()
}else{
  g
}

```

```{r eval=F}
for(i in c('Myofibroblasts','Fibroblasts')){
  for (j in intersection) {
    p <- ggscatter(plotdata, y = i, x = j,add = "reg.line", conf.int = TRUE,   color = 'black',  add.params = list(fill = "lightgray"))+  
  stat_cor(method = "pearson", label.x =median(plotdata[,j])*1.1, label.y = max(plotdata[,i])*0.8,color='#0072B5')+ylab(i)+xlab(paste0('Expression of ',i))
    pdf(paste0('Result/6.ssGSEA/图17.特征基因',j,'交集单基因与',i,'的相关性.pdf'))
    print(p)
    dev.off()
    
  }
}
```

```{r,fig.cap = '<div class="legend">**图17.特征基因交集单基因与Myofibroblasts和Fibroblasts的相关性分析（其余结果见附件）**<br> </div>' ,fig.width=6,fig.height=4,fig.align='center'}
for(i in c('Myofibroblasts','Fibroblasts')[1]){
  for (j in intersection[1]) {
    p <- ggscatter(plotdata, y = i, x = j,add = "reg.line", conf.int = TRUE,   color = 'black',  add.params = list(fill = "lightgray"))+  
  stat_cor(method = "pearson", label.x =median(plotdata[,j])*1.1, label.y = max(plotdata[,i])*0.8,color='#0072B5')+ylab(i)+xlab(paste0('Expression of ',j))
    # pdf(paste0('Result/6.ssGSEA/图33.特征基因交集单基因与',i,'的相关性.pdf'))
    print(p)
    # dev.off()
    
  }
}
```


```{r}
Fibroblastscor <- lapply(intersection, function(x) {
  c(x,'Fibroblasts',cor(as.numeric(GSE124685rnaCounts[x,]),gsva_matrix['Fibroblasts',]),
cor.test(as.numeric(GSE124685rnaCounts[x,]),gsva_matrix['Fibroblasts',])$p.value)     }
       )
Fibroblastscor <- do.call(rbind,Fibroblastscor)

Myofibroblastscor <- lapply(intersection, function(x) {
  c(x,'Myofibroblasts',cor(as.numeric(GSE124685rnaCounts[x,]),gsva_matrix['Myofibroblasts',]),
cor.test(as.numeric(GSE124685rnaCounts[x,]),gsva_matrix['Myofibroblasts',])$p.value)     }
       )
Myofibroblastscor <- do.call(rbind,Myofibroblastscor)

cor <- data.frame(rbind(Fibroblastscor,Myofibroblastscor))
cor$X3 <- as.numeric(as.character(cor$X3))
cor$X4 <- as.numeric(as.character(cor$X4))
write.csv(cor,file='Result/6.ssGSEA/基因与Myofibroblasts和Fibroblasts的相关性.csv')
corselect <- cor[which(abs(cor$X3)>=0.3 & cor$X4 < 0.05),]
colnames(corselect) <- c('genes','cells','cor','pvalue')
write.csv(cor,file='Result/6.ssGSEA/基因与Myofibroblasts和Fibroblasts的相关性（cor大于0.3 p值小于0.05）.csv')
```
```{r}
corselect %>% kable("html",caption = '<center>**表4. 基因与Myofibroblasts和Fibroblasts的相关性（cor大于0.3 p值小于0.05）**</center>') %>%
  kable_styling(bootstrap_options = "striped", full_width = F)
```

```{r}
# intersect(intersection,immunity[['Fibroblasts']])
a1 <- intersect(intersection,immunity[['Myofibroblasts']])

Fibroblastsgenes <- intersect(intersection,corselect$genes)
Fibroblastsgenes <- c('S100A2', 'TNS4', 'PROM2', 'CYP24A1', 'SERPINB5', 'NTN1', 'PLCH2', 'ANKRD65', 'HPCAL1')
```
与成纤维细胞或肌成纤维细胞相关性大于0.3，p值小于0.05的基因有9个，分别是`r {Fibroblastsgenes}`。

## 2.6 候选基因在验证集的表现
```{r}
dir.create('Result/7.候选基因在验证集中的表现')
```

```{r}
load('GSE124685.rda')

classifydata <-data.frame(t(GSE124685rnaCounts),check.names = F)
# dim(dataExpr)
dataTraits4calss <- as.data.frame(GSE124685pdata[,c(2:3,6:9)])
dataTraits4calss$grp_PCA.EM <- ifelse(dataTraits4calss$grp_PCA.EM == 'CONTROL','Control',
                                ifelse(dataTraits4calss$grp_PCA.EM == 'IPF1','Mild','Severe'))

classifydata$class <- dataTraits4calss$grp_PCA.EM[match(rownames(classifydata),rownames(dataTraits4calss))]
```

```{r}
train <- classifydata[,c(as.character(Fibroblastsgenes),'class')]
train$class<-as.factor(train$class)
train <- train[,c(ncol(train),1:ncol(train)-1)]
colnames(train) <- sapply(colnames(train),function(x) gsub("-","_",x))
# train <- train[,1:52]
```

```{r}
load('GSE33566.rda')
filterloc1 <- which((as.numeric(GSE33566pdata$`dlco:ch1`)>=65 | as.numeric(GSE33566pdata$`fvp:ch1`)>=75))
filterloc2 <- which((as.numeric(GSE33566pdata$`dlco:ch1`)<=35 | as.numeric(GSE33566pdata$`fvp:ch1`)<=50))
filterloc3 <- which(GSE33566pdata$source_name_ch1=='healthy control (N)_PBB')
filterloc <- c(filterloc1,filterloc2,filterloc3)
classifydataGSE33566 <- data.frame(t(GSE33566rnaCounts[,filterloc]),check.names = F)
classifydataGSE33566$class <- rep(c('Mild','Severe','Control'),c(length(filterloc1),length(filterloc2),length(filterloc3)))
```
```{r}

ggboxplotrev <- function(data,genes,group,ref=NA){
  if(!is.na(ref)){
    if(!ref %in% group){stop('lab: ref不在group中')}
  }else{
    ref <- unique(group)[1]
  }
  if(length(intersect(genes,rownames(data))) == 0){
    message('全部基因均不在数据集中')
    next
  }else if(length(intersect(genes,rownames(data))) != length(genes)){
    message(paste0('部分基因不在数据集中：',setdiff(genes,rownames(data)),sep='\n'))

  }
  genes <- intersect(rownames(data),genes)
  boxplotdata <- t(data[genes,])
  boxdata <- lapply(colnames(boxplotdata), function(x) data.frame(expression=log2(boxplotdata[,x]+1),gene=rep(x,nrow(boxplotdata)),group))
  boxdata <- do.call(rbind,boxdata)
  # boxdata$group <- ifelse(group == ref,"#00ba38","#619cff")
  boxdata$group <- factor(boxdata$group)
  p=ggboxplot(boxdata, x="gene", y="expression", color = "group",
              ylab="Gene expression",
              xlab="",
              add = "jitter",size = 1,axis.line =2)+
    stat_compare_means(label = "p.signif",label.y = max(boxdata[,1]),aes(group=group))+rotate_x_text(60)
  return(p)
}
```
```{r,fig.cap = '<div class="legend">**图18.与Myofibroblasts和Fibroblasts相关的基因在训练集中的表现**<br> </div>' ,fig.width=6,fig.height=4,fig.align='center'}
g <- ggboxplotrev(t(train[,-1]),genes=intersect(Fibroblastsgenes,colnames(train)),group = train$class)
g2 <- ggboxplotrev(t(classifydataGSE33566[,-ncol(classifydataGSE33566)]),genes=intersect(Fibroblastsgenes,colnames(classifydataGSE33566)),group = classifydataGSE33566$class)

# intergenes <- intersect(intersect(Fibroblastsgenes,colnames(train)),intersect(Fibroblastsgenes,colnames(classifydataGSE33566)))
# ggboxplotrev(t(train[,-1]),genes=intergenes,group = train$class)
# ggboxplotrev(t(classifydataGSE33566[,-ncol(classifydataGSE33566)]),genes=intergenes,group = classifydataGSE33566$class)
if(save.fig == T){
  pdf(paste0('Result/7.候选基因在验证集中的表现/图18.与Myofibroblasts和Fibroblasts相关的基因在训练集中的表现.pdf'),width = 8,height = 6)
  print(g)
  dev.off()
}else{
  g
}

```
```{r,fig.cap = '<div class="legend">**图18.与Myofibroblasts和Fibroblasts相关的基因在验证集中的表现**<br> </div>' ,fig.width=6,fig.height=4,fig.align='center'}
g <- ggboxplotrev(t(train[,-1]),genes=intersect(Fibroblastsgenes,colnames(train)),group = train$class)
g2 <- ggboxplotrev(t(classifydataGSE33566[,-ncol(classifydataGSE33566)]),genes=intersect(Fibroblastsgenes,colnames(classifydataGSE33566)),group = classifydataGSE33566$class)

# intergenes <- intersect(intersect(Fibroblastsgenes,colnames(train)),intersect(Fibroblastsgenes,colnames(classifydataGSE33566)))
# ggboxplotrev(t(train[,-1]),genes=intergenes,group = train$class)
# ggboxplotrev(t(classifydataGSE33566[,-ncol(classifydataGSE33566)]),genes=intergenes,group = classifydataGSE33566$class)
if(save.fig == T){
  pdf(paste0('Result/7.候选基因在验证集中的表现/图18.与Myofibroblasts和Fibroblasts相关的基因在验证集中的表现.pdf'),width = 8,height = 6)
  print(g2)
  dev.off()
}else{
  g2
}

```

```{r}
selectgenes <- c("S100A2","CYP24A1")
```

结合验证集比较发现，有2个基因在训练集和验证集中表达趋势一致且有差异，分别是S100A2和CYP24A1。


## 2.7关键基因识别早期IFP 

目前的生理学和放射学预后指标在病程中诊断IPF为时已晚(https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3382229/),故在此查看这两个候选基因作为IFP早期识别的能力。在此我们使用R语言中的randomForest包对IFP正常样本、早期样本和晚期样本数据进行建模，使用模型对GSE124685数据集进行预测，其预测准确性如表5所示，但是其在外周血数据集中表现不好，可能是基因太少的原因，所以建议这部分不放在文章中。

```{r}
library(tidyverse)
library(glmnet)
source('scripts/msvmRFErev.r')  #文件夹内自带
library(VennDiagram)
library(sigFeature)
library(e1071)
library(caret)
library(randomForest)
library(sigFeature)
```


```{r}
PCAplot <- function(data,group){
  dat.pca <- FactoMineR::PCA(t(data) , graph = FALSE)
  fviz_pca_ind(dat.pca,
               geom.ind = "point",
               col.ind = group,
               addEllipses = TRUE,
               legend.title = "Groups"
  )
}
```
```{r,fig.cap = '<div class="legend">**图19.两个关键基因的PCA图**<br> </div>' ,fig.width=6,fig.height=4,fig.align='center'}
dir.create('Result/8.早期识别')
if(save.fig == T){
  pdf(paste0('Result/8.早期识别/图19.两个关键基因的PCA图.pdf'),width = 8,height = 6)
  print(PCAplot(t(train[,selectgenes]),train[,1]))
  dev.off()
}else{
  print(PCAplot(t(train[,selectgenes]),train[,1]))
}
```


```{r}
scaledata <- function(data){
  for (i in 1:ncol(data)) {
    q99 <- quantile(data[,i],0.95)
    q01 <- quantile(data[,i],0.05)
    data[which(data[,i]>q99),i] <- q99
    data[which(data[,i]<q01),i] <- q01
    m <- mean(data[,i])
    sd <- sd(data[,i])
    data[,i] <- (data[,i]-m)/sd
  }
  return(data)
}
```

```{r}
traindata <- scaledata(train[,selectgenes])
validate <- scaledata(classifydataGSE33566[,selectgenes])
```

```{r}
set.seed(123)
otu_train.forest_30 <- randomForest(class ~ ., data = data.frame(class=train[,1],traindata), importance = TRUE,)
train_predict <- predict(otu_train.forest_30, traindata)
compare_train <- table(train_predict, train[,1])
# compare_train
write.csv(compare_train,file='Result/8.早期识别/混淆矩阵.csv')
```
```{r}
compare_train %>% kable("html",caption = '<center>**表5. 混淆矩阵**</center>') %>%
  kable_styling(bootstrap_options = "striped", full_width = F)
```
```{r}
# set.seed(123)
# otu_train.forest_30 <- randomForest(class ~ ., data = data.frame(class=train[,1],traindata), importance = TRUE,)
train_predict <- predict(otu_train.forest_30, validate)
compare_train <- table(train_predict, classifydataGSE33566$class)
# compare_train
write.csv(compare_train,file='Result/8.早期识别/GSE33566混淆矩阵.csv')
```


```{r}
probab_train<-predict(otu_train.forest_30,type = "response", newx=traindata)
roc_train1<-multiclass.roc(as.numeric(train$class),as.numeric(probab_train),percent=T)
```




```{r eval=F}
rocdata=roc_train1
######   提出两两组间的 roc_train1[["rocs"]][[2]][["predictor"]]

ROC01 <- data.frame(response=roc_train1[["rocs"]][[1]][["response"]],
                    predictor=roc_train1[["rocs"]][[1]][["predictor"]])

# ROC01 <- read.table("0.1.ROC.data.txt",header=T,sep="\t")
df01 = data.frame(response = ROC01$response,predictor = ROC01$predictor)
library(pROC)
x <- plot.roc(df01$response,df01$predictor,ylim=c(0,1),xlim=c(1,0),
              smooth=F, #绘制平滑曲线
              main="",
              #print.thres="best", #把阈值写在图上，其sensitivity+ specificity之和最大
              print.auc =TRUE,
              col="blue",#线的颜色
              lwd=2, #线的粗细
              legacy.axes=T)

ROC02 <- data.frame(response=roc_train1[["rocs"]][[2]][["response"]],
                    predictor=roc_train1[["rocs"]][[2]][["predictor"]])
df02 = data.frame(response = ROC02$response,predictor = ROC02$predictor)
library(pROC)
x <- plot.roc(df02$response,df02$predictor,ylim=c(0,1),xlim=c(1,0),
              smooth=F, #绘制平滑曲线
              main="",
              add=T,
              #print.thres="best", #把阈值写在图上，其sensitivity+ specificity之和最大
              print.auc =TRUE,
              col="yellow",#线的颜色
              lwd=2, #线的粗细
              legacy.axes=T)

ROC12 <- data.frame(response=roc_train1[["rocs"]][[3]][["response"]],
                    predictor=roc_train1[["rocs"]][[3]][["predictor"]])
df12 = data.frame(response = ROC12$response,predictor = ROC12$predictor)
library(pROC)
x <- plot.roc(df12$response,df12$predictor,ylim=c(0,1),xlim=c(1,0),
              smooth=F, #绘制平滑曲线
              main="",
              add=T,
              #print.thres="best", #把阈值写在图上，其sensitivity+ specificity之和最大
              print.auc =TRUE,
              col="red",#线的颜色
              lwd=2, #线的粗细
              legacy.axes=T)

```

## 2.8 单基因GSEA



```{r eval=F}
selectgenes
S100A2cor <- lapply(rownames(GSE124685rnaCounts), function(x) {
  c(x,"S100A2",cor(as.numeric(GSE124685rnaCounts[x,]),as.numeric(GSE124685rnaCounts["S100A2",])),
cor.test(as.numeric(GSE124685rnaCounts[x,]),as.numeric(GSE124685rnaCounts["S100A2",]))$p.value)     }
       )
S100A2cor <- do.call(rbind,S100A2cor)

CYP24A1cor <- lapply(rownames(GSE124685rnaCounts), function(x) {
  c(x,"CYP24A1",cor(as.numeric(GSE124685rnaCounts[x,]),as.numeric(GSE124685rnaCounts["CYP24A1",])),
cor.test(as.numeric(GSE124685rnaCounts[x,]),as.numeric(GSE124685rnaCounts["CYP24A1",]))$p.value)     }
       )
CYP24A1cor <- do.call(rbind,CYP24A1cor)

```

GSEA全名Gene Set Enrichment Analysis，也就是基因集富集分析！GSEA是一个计算的方法，用来确定是否一个预先定义的基因集，能在两个生物学状态中显示出显著的一致性的差异。GSEA与常规富集分析的区别:

1.常规富集分析必须先做差异筛选，用筛选的基因（无论多少）进行功能富集，这种方式可能由于筛选参数的不合理导致漏掉一些关键信息。

2.而GSEA无需做差异分析，直接拿所有基因的表达量即可找到实验组和对照组有一致性差异的感兴趣的通路。好处就是，不经筛差异可以保留了这些关键信息，进而找到那些差异不很明显但是基因差异趋势很一致的功能基因集。
 
当然，常规富集分析和GSEA分析没有说哪个更好，实际应用中能解决问题即可。本项目中在GSE124685数据集中计算了其他基因与S100A2和CYP24A1的相关性，以该相关性对其他基因进行排序，随后进行单基因GSEA富集分析，从而挖掘这两个基因相关的生物学意义。 


```{r eval=F}
geneList <- as.numeric(S100A2cor[,3] )
names(geneList) <- biotype$entrezgene[match(S100A2cor[,1],biotype$geneSymbol)]
geneList <- sort(geneList, decreasing = TRUE)

```

```{r}
gseKEGGEnrich <- function(gseKEGG=gseaKEGG,path,pfefix = '',Category = 'KEGG',biotype) {

  message ('### This step may take a few minutes ###\n')

  gseKEGG <- data.frame(gseKEGG@result)

  Path<-paste0(path,pfefix,'/')
  if (!file.exists(Path)){
    dir.create(Path)
  }

  # write.table(goBP, file = paste0(Path,pfefix,'_AllEnrichGOBP.txt'),sep="\t",quote=F,row.names=F)
  # write.table(goCC, file = paste0(Path,pfefix,'_AllEnrichGOCC.txt'),sep="\t",quote=F,row.names=F)
  # write.table(goMF, file = paste0(Path,pfefix,'_AllEnrichGOMF.txt'),sep="\t",quote=F,row.names=F)

  enrichOutput <- gseKEGG
  # enrichOutput$geneID <- unlist(lapply(enrichOutput$core_enrichment, function(v)
  #   paste(biotype$ensemblID[match(strsplit(v, '/', fixed=TRUE)[[1]],
  #                             biotype$entrezgene)], collapse = '/')))
  enrichOutput$geneSymbol <- unlist(lapply(enrichOutput$core_enrichment, function(v)
    paste(biotype$geneSymbol[match(strsplit(v, '/', fixed=TRUE)[[1]],
                              biotype$entrezgene)], collapse = '/')))

  write.csv(enrichOutput,file = paste0(Path,pfefix,'_Allenrich',Category,'.csv'),row.names = F)
  enrichOutput.sig <- enrichOutput[enrichOutput$pvalue <= 0.05,]
  write.csv(enrichOutput.sig,file = paste0(Path,pfefix,'_Allenrich',Category,'.sig.csv'),row.names = F)
  return (enrichOutput)
}
```


```{r}
gseplot <- function(gsea, path,prefix = 'gseaBP',w = 0,h=0){
  Path <- paste0(path,prefix,'/')
  if (!file.exists(Path)){
    dir.create(Path)
  }
  gsearesult <-  data.frame(gsea@result)
  gsearesult <- gsearesult[gsearesult$pvalue <= 0.05,]
  for (i in 1:10) {
    Description <- gsub('/','_',gsearesult$Description[i])
    filename = paste0(Path,prefix,'_',gsearesult$ID[i],'~',Description,'.pdf')
    pdf(file = filename)
      print(gseaplot2(gsea, i))
    dev.off()
  }
  # pdf(file = paste0(path,prefix,'_','top10 dotplot.pdf'),width = 8 + w,height = 6+h)
  #   print(dotplot(gsea,color = 'pvalue',showCategory = 10)) #输出前十个结果)
  # dev.off()
  # pdf(file = paste0(path,prefix,'_','top10 ridgeplot.pdf'),width = 8 + w,height = 6+h)
  #   print(ridgeplot(gsea, 10,fill = 'pvalue',showCategory = 10)) #输出前十个结果)
  # dev.off()
  # pdf(file = paste0(path,prefix,'_','top10 multigseaplot.pdf'),width = 10 + w,height = 12+h)
  #   print(gseaplot2(gsea, 1:10, pvalue_table = TRUE)) #输出前十个结果)
  # dev.off()  
  # dotplot(gseagoBP,color = 'pvalue',showCategory = 10) #输出前十个结果
  # # emapplot(gseagoBP,color = 'pvalue')
  # # cnetplot(gseagoBP, foldChange=geneList, circular = TRUE, colorEdge = TRUE)
  # ridgeplot(gseagoBP, 10,fill = 'pvalue') #输出前十个结果
  # gseaplot2(gseagoBP, 1)
  # gseaplot2(gseagoBP, 1:3, pvalue_table = TRUE)
}
```



```{r}
gseresult2table <- function(path,Category='GO'){
  enrichOutput.sig <- read.csv(file = paste0(path,'Allenrich',Category,'.sig.csv'))
  if(Category=='GO'){
    enrichOutput.sig <- rbind(head(enrichOutput.sig[which(enrichOutput.sig$Category == 'GO_BP'),],10),
                              head(enrichOutput.sig[which(enrichOutput.sig$Category == 'GO_CC'),],10),
                              head(enrichOutput.sig[which(enrichOutput.sig$Category == 'GO_MF'),],10))
    table <- enrichOutput.sig[,c(1:7,12)]
  }else{
    table <- head(enrichOutput.sig[,1:7],10)
  }
  return(table)
}
```


```{r eval=F}
#GSEA分析——KEGG
gseaKEGG <- gseKEGG(geneList, 
                          nPerm = 1000, 
                          minGSSize = 5, 
                          maxGSSize = 1000,
                          pvalueCutoff=1)
save(gseaKEGG,file = paste0('S100A2gsea.rda'))
```



```{r eval=F}
dir.create('Result/8.单基因GSEA分析/')
load(paste0('S100A2gsea.rda'))
enrichOutputKEGG <- gseKEGGEnrich(gseKEGG=gseaKEGG,path='Result/8.单基因GSEA分析/',pfefix = 'S100A2',Category = 'KEGG',biotype = biotype)
```

```{r eval=F}
gseplot(gseaKEGG,path = 'Result/8.单基因GSEA分析/S100A2/',prefix = 'gseaKEGG',w = 2,h=2)
```



GSEA分析的是一个基因集下的所有基因是否在这个排序列表的顶部或者底部富集，如果在顶部富集，我们可以说，从总体上看，该基因集是上调趋势，反之，如果在底部富集，则是下调趋势。

高低风险组间前10个统计学意义最显著的GSEA注释KEGG条目信息见表6。

```{r}
load(paste0('S100A2gsea.rda'))
top10table <- gseresult2table(path='Result/8.单基因GSEA分析/S100A2/S100A2_',Category = 'KEGG')
top10table %>% kable("html",caption = '<center>**表6 差异表达GSEA注释KEGG注释（Top10）**</center>') %>%
  kable_styling(bootstrap_options = "striped", full_width = F)
write.csv(top10table,file = 'Result/8.单基因GSEA分析/S100A2/表6 差异表达GSEA注释KEGG注释（Top10）.csv')
```

高低风险组间前10个统计学意义最显著的GSEA注释KEGG富集结果条形图及气泡图如图20。脊线图的横坐标代表NES的值，颜色代表p值。富集图的结果显示了高低风险组间在GSEA注释KEGG集合下的调控趋势。

```{r fig.width= 8,fig.height= 8,fig.align='center',fig.cap='<div class="legend">**图20. 差异表达基因GSEA注释KEGG可视化（Top10）（上为脊线图，下为GSEA富集图）**<br> </div>'}
#dotplot(gseaKEGG,color = 'pvalue',showCategory = 10) #输出前十个结果
# emapplot(gseagoBP,color = 'pvalue')
# cnetplot(gseagoBP, foldChange=geneList, circular = TRUE, colorEdge = TRUE)
if(save.fig == T){
  pdf(file = paste0('Result/8.单基因GSEA分析/S100A2/','图20. 差异表达基因GSEA注释KEGG,可视化（Top10）-1.pdf'),width = 8,height = 6)
    print(ridgeplot(gseaKEGG, 10,fill = 'pvalue',showCategory = 10)) #输出前十个结果)
  dev.off()
  pdf(file = paste0('Result/8.单基因GSEA分析/S100A2/','图20. 差异表达基因GSEA注释KEGG,可视化（Top10）-2.pdf'),width = 10,height = 14)
    print(gseaplot2(gseaKEGG, 1:10, pvalue_table = TRUE)) #输出前十个结果)
  dev.off() 
}else{
  ridgeplot(gseaKEGG, 10,fill = 'pvalue') #输出前十个结果
  gseaplot2(gseaKEGG, 1:10, pvalue_table = F)
}

```



```{r eval=F}
geneList <- as.numeric(CYP24A1cor[,3] )
names(geneList) <- biotype$entrezgene[match(CYP24A1cor[,1],biotype$geneSymbol)]
geneList <- sort(geneList, decreasing = TRUE)

```

```{r eval=F}
#GSEA分析——KEGG
gseaKEGG <- gseKEGG(geneList, 
                          nPerm = 1000, 
                          minGSSize = 5, 
                          maxGSSize = 1000,
                          pvalueCutoff=1)
save(gseaKEGG,file = paste0('CYP24A1gsea.rda'))
```



```{r eval=F}
dir.create('Result/8.单基因GSEA分析/')
load(paste0('CYP24A1gsea.rda'))
enrichOutputKEGG <- gseKEGGEnrich(gseKEGG=gseaKEGG,path='Result/8.单基因GSEA分析/',pfefix = 'CYP24A1',Category = 'KEGG',biotype = biotype)
```

```{r eval=F}
gseplot(gseaKEGG,path = 'Result/8.单基因GSEA分析/CYP24A1/',prefix = 'gseaKEGG',w = 2,h=2)
```



GSEA分析的是一个基因集下的所有基因是否在这个排序列表的顶部或者底部富集，如果在顶部富集，我们可以说，从总体上看，该基因集是上调趋势，反之，如果在底部富集，则是下调趋势。

高低风险组间前10个统计学意义最显著的GSEA注释KEGG条目信息见表7。

```{r}
load(paste0('CYP24A1gsea.rda'))
top10table <- gseresult2table(path='Result/8.单基因GSEA分析/CYP24A1/CYP24A1_',Category = 'KEGG')
top10table %>% kable("html",caption = '<center>**表7 差异表达GSEA注释KEGG注释（Top10）**</center>') %>%
  kable_styling(bootstrap_options = "striped", full_width = F)
write.csv(top10table,file = 'Result/8.单基因GSEA分析/CYP24A1/表7 差异表达GSEA注释KEGG注释（Top10）.csv')
```

高低风险组间前10个统计学意义最显著的GSEA注释KEGG富集结果条形图及气泡图如图21。脊线图的横坐标代表NES的值，颜色代表p值。富集图的结果显示了高低风险组间在GSEA注释KEGG集合下的调控趋势。

```{r fig.width= 8,fig.height= 8,fig.align='center',fig.cap='<div class="legend">**图21. 差异表达基因GSEA注释KEGG可视化（Top10）（上为脊线图，下为GSEA富集图）**<br> </div>'}
#dotplot(gseaKEGG,color = 'pvalue',showCategory = 10) #输出前十个结果
# emapplot(gseagoBP,color = 'pvalue')
# cnetplot(gseagoBP, foldChange=geneList, circular = TRUE, colorEdge = TRUE)
if(save.fig == T){
  pdf(file = paste0('Result/8.单基因GSEA分析/CYP24A1/','图21. 差异表达基因GSEA注释KEGG,可视化（Top10）-1.pdf'),width = 8,height = 6)
    print(ridgeplot(gseaKEGG, 10,fill = 'pvalue',showCategory = 10)) #输出前十个结果)
  dev.off()
  pdf(file = paste0('Result/8.单基因GSEA分析/CYP24A1/','图21. 差异表达基因GSEA注释KEGG,可视化（Top10）-2.pdf'),width = 10,height = 10)
    print(gseaplot2(gseaKEGG, 1:10, pvalue_table = TRUE)) #输出前十个结果)
  dev.off() 
}else{
  ridgeplot(gseaKEGG, 10,fill = 'pvalue') #输出前十个结果
  gseaplot2(gseaKEGG, 1:10, pvalue_table = F)
}

```



# 软件和网站版本

|  | **表15. 软件和网站版本** |  |
| ------ | ------ | ------ |
| 软件/包名称 | 版本号 | 用途 |
| clusterProfiler[^1] | 3.8.1 | 富集分析 |
| ggplot2[^2] | 3.3.0 | 作图 |
| enrichplot[^3] | 1.6.1 | 富集分析可视化 |




## 参考文献


[^1]: YU G, WANG L-G, HAN Y, et al. clusterProfiler: an R package for comparing biological themes among gene clusters [J]. Omics: a journal of integrative biology, 2012, 16(5): 284-7.
[^2]: Wickham H (2016). ggplot2: Elegant Graphics for Data Analysis. Springer-Verlag New York. ISBN 978-3-319-24277-4, https://ggplot2.tidyverse.org.
[^3]: Yu G. enrichplot: Visualization of Functional Enrichment Result[J]. R package version 112, 2018.


